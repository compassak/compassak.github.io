[
{
	"uri": "https://compass-ak.gitee.io/python/selenium/",
	"title": "selenium",
	"tags": [],
	"description": "",
	"content": " selenium "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/graphs/undigraph/",
	"title": "1. Undigraph",
	"tags": [],
	"description": "",
	"content": " 无向图 -图片资料来自 Algorithms, 4th Edition\n图：图是由一组顶点和一组能够将两个顶点相连的边组成。\n一般情况下为了和其他的图模型相互区别，又称图为无向图。在现实中的许多问题都可以抽象为一张图，结合优秀的算法，许多困难的问题都可以迎刃而解。\n1. 术语表 和图有关的术语，定义非常多，其一部分内容如下：\n   术语 条件（释义）     顶点相邻 两个顶点通过一条边相连时，并称这条边 依附于 这两个顶点   顶点的度数 连接它边的总数   子图 指定图的子集   路径 由边顺序连接的一系列顶点   简单路径 一条没有重复顶点的路径   环 含有至少一条边且起点和终点相同的路径   简单环 除起点和终点相同外，不含有重复顶点和边的环   顶点连通 两个顶点间存在一条连接双方的路径时   连通图 图中任意一个顶点都存在一条路径到达另外一个顶点   极大连通子图 非连通图的一个连通部分   无环图 不包含环的图   图密度 指已经连接的顶点对占所有可能被连接顶点对的比例   稀疏图 很少的顶点对被连接   稠密图 很少的顶点对没有被连接   二分图 顶点可分割为两个互不相交的子集，两个子集内的顶点不相邻    2. 表示无向图数据类型 2.1 图的几种表示方法\n图的表示方法主要有以下3种：\n 邻接矩阵：使用一个长宽等于顶点数的布尔矩阵来表示图，当顶点 v 与顶点 w 之间有相连的边时，置 v 行 w 列的元素值为true，否则为false。由于现实的问题抽象出的往往是顶点数非常大的稀疏图，使用这种方法表示图会浪费掉大量资源.\n 边的数组：使用一个 Edge 类，含两个 int 实例变量。这种方法的缺点是无法快速的找到一个顶点相邻的顶点。\n 邻接表：使用一个以顶点为索引的列表数组，数组中每一个索引位置元素都是和对应顶点的所有相邻顶点构成的链表。与 基于拉链法的哈希表 逻辑结构类似。这种方法表示图既不会浪费很多资源，又可以非常快的查询到一个与顶点相邻的所有顶点。\n  2.2 邻接表的表示\n前面描述了邻接表的逻辑结构，实现它就很简单了。只需要声明一个静态内部结点类作为以顶点为索引的数组中的元素，结点有顶点号以及指向下一个元素的引用，这样就可以通过数组直接访问到一条条邻接顶点链表。\n2.3 实现\n声明一个 Node 数组作为邻接表，在两个构造函数中完成对图的初始化，使用reader初始化图时，读取的文件头两行应为顶点数和边数。在添加一条边时，需要在两个顶点的邻接表中都加上对方的顶点结点。这样方便我们在实现 adj() 方法时可以简单高效的找出一个顶点的所有邻接顶点。\nJava\npublic class Graph { private final int V; // 顶点数 private int E; // 边数 private Node[] adj; // 邻接表 /** * 邻接表结点静态内部类 */ private static class Node{ int vertex; // 顶点 Node next; // 下一个元素的引用 Node(){} Node(int vertex, Node next){ this.vertex = vertex; this.next = next; } } public Graph(int V){ this.V = V; this.E = 0; this.adj = new Node[V]; // 创建邻接表 } public Graph(BufferedReader reader) throws IOException { this(Integer.parseInt(reader.readLine())); // 读取 V int E = Integer.parseInt(reader.readLine()); // 读取 E for (int i = 0; i \u0026lt; E; i ++){ String str = reader.readLine(); String[] edge= str.split(\u0026quot; \u0026quot;); int v = Integer.parseInt(edge[0]); int w = Integer.parseInt(edge[1]); addEdge(v, w); // 添加边 } } /** * 添加一条边 * @param v 顶点1 * @param w 顶点2 */ public void addEdge(int v, int w){ Node first = adj[v]; adj[v] = new Node(w, first); // 将w添加到v的链表中 first = adj[w]; adj[w] = new Node(v, first); // 将v添加到w的链表中 E++; } /** * 获取与顶点 v 邻接的所有顶点 * @param v 顶点 * @return 邻接顶点set集合 */ public Set\u0026lt;Integer\u0026gt; adj(int v){ Node node = adj[v]; Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while (node != null){ set.add(node.vertex); node = node.next; } return set; } public int V(){ return V;} public int E(){ return E;} }  在上面的实现中，可能几个不同的邻接表对应同一幅图，这与边插入的顺序有关。而且在最后调用方法 adj() 获取所有邻接顶点时，使用的是 HashSet 存储顶点元素又会将元素的顺序打乱（按在HashSet中的存储位置顺序），此时元素的顺序就是算法处理它们的顺序。虽然顺序的差异不会对算法的正确性有影响。\n3. 深度优先搜索 深度优先搜索（DFS）是一种遍历连通图的算法，它算法的基本思路为：\n 从一个指定的顶点（起点）开始遍历。\n 将访问过的顶点标记为已访问。\n 递归的访问当前顶点所有没有被标记过的邻接顶点。\n  深度优先搜索可以通俗的理解为一条道走到黑遍历算法，首先它会访问起点的第一个邻接顶点，然后又会访问第一个邻接顶点的第一个邻接顶点。如此递归下去，当到访问到一个已经被访问的顶点，往后退一步继续递归访问，直到所有与起点连通的顶点都被访问过后，算法结束。\n可以说是非常的头铁了，给人一种到处乱串的感觉，一直走到相对于起点的最深处才罢休。它的基本实现如下（基于 Graph 数据类型）。\nJava\npublic class DepthFirstSearch { private boolean[] marked; // 标记已访问过的顶点 private int count; // 与起点连通的结点数 public DepthFirstSearch(Graph g, int s){ marked = new boolean[g.V()]; dfs(g, s); } /** * 深度优先搜索函数 * @param g 图 * @param v 当前顶点 */ private void dfs(Graph g, int v){ marked[v] = true; count++; for (int w : g.adj(v)) if (!marked[w]) dfs(g, w); } /** * 查看顶点 w 是否与起点联通 * @param w 顶点 * @return 联通 true，不连通 false */ public boolean marked(int w){ return marked[w]; } /** * 获取与起点联通的结点数 * @return 结点数 */ public int count(){ return count; } }  有了深度优先搜索我们可以解决很多图的问题：\n 计算一幅图的极大连通子图数(连通分量)\n 确定两个顶点是否连通（两个顶点间是否存在一条路径）。\n 判断一幅图是否存在环。\n 判断一幅图是不是二分图。\n  等等，图论中的许多问题都可以使用深度优先搜索来解决。只需要在经典的深度优先搜索上稍加修改（记录一下数据）即可。\n3.1 连通分量\n图的连通分量也就是图的极大连通子图。基于深度优先搜索计算一幅图的连通分量数的思路是：利用深度优先搜索每次都会遍历完一个包含起点的连通图的性质。将每一个顶点都轮流作为起点，找到一幅连通子图计数器加一。\n在CC的实现中，使用一个int数组 id 来存储每一个顶点的连通分量id（初始化时对应的count），顶点号为数组索引，数组值为连通分量的id。根据id数组我们可以很快的确定两个顶点是否在一个连通分量中（是否连通，之间有路径）。每找到一个连通分量 count加1。具体实现如下。\npublic class CC { private boolean[] marked; // 标记已访问过的顶点 private int[] id; // 顶点对应索引，值为连通分量的id private int count; // 连通分量数 public CC(Graph g){ marked = new boolean[g.V()]; id = new int[g.V()]; for (int s = 0; s \u0026lt; g.V(); s++){ if (!marked[s]){ dfs(g, s); count++; } } } /** * 深度优先搜索函数 * @param g 图 * @param v 当前顶点 */ private void dfs(Graph g, int v){ marked[v] = true; id[v] = count; for (int w : g.adj(v)) if (!marked[w]) dfs(g, w); } public boolean connected(int v, int w){ return id[v] == id[w]; } public int id(int v){ return id[v]; } public int count(){ return count; } }  3.2 判断环\n基于深度优先搜索检测图中是否含有环的基本思路为：在有顶点的边指向已标记的顶点，且已标记顶点不是当前顶点的父顶点时，判定图出现环。这里的父顶点是根据访问顺序来确定，也就是当前顶点前一个被访问的顶点。\n在 Cycle 的实现中，增加了 dfs() 的参数 int u，也就是参数int v 的父顶点用于环判定。\n/** * 判断图中是否有环，假设不存在自环，平行环 */ public class Cycle { private boolean[] marked; // 标记已访问过的顶点 private boolean hasCycle; // 是否含有环 public Cycle(Graph g){ marked = new boolean[g.V()]; for (int s = 0; s \u0026lt; g.V(); s++) if (!marked[s]) dfs(g, s, s); } /** * 深度优先搜索函数（在有顶点的边指向已标记的顶点，且已标记顶点不是当前顶点的父顶点时，判定图出现环） * @param g 图 * @param v 当前顶点 * @param u 上一个访问的顶点（v的父顶点） */ private void dfs(Graph g, int v, int u){ marked[v] = true; for (int w : g.adj(v)) if (!marked[w]) dfs(g, w, v); else if (w != u) hasCycle = true; } public boolean HasCycle(){ return hasCycle; } }  3.3 判断图是否为二分图\n二分图的定义在术语表中提到过：顶点可分割为两个互不相交的子集，两个子集内的顶点不相邻。也就是说需要每一条边连接的两个顶点是不同的颜色，所有顶点又分别属于两种颜色。\n基于深度优先搜索判断二分图的思路为：这个问题正向证明不是很容易，我们使用反证法。使用深度优先遍历整幅图，在遍历的过程中按二分图定义给顶点上色。如果访问到一个已上色的顶点且其颜色与父顶点相同那么此图就无法构成一个二分图。\n在 TowColor 的实现中，使用一个int[] 的 color 记录每一个顶点的颜色。isTowColorable 默认为 true，遇到无法构成2分图的情况置为 false。\npublic class TowColor { private boolean[] marked; // 标记已访问过的顶点 private boolean[] color; // 顶点颜色 private boolean isTowColorable = true; // 当前图是否可以构成二分图 public TowColor(Graph g){ marked = new boolean[g.V()]; color = new boolean[g.V()]; for (int s = 0; s \u0026lt; g.V(); s++) if (!marked[s]) dfs(g, s); } /** * 深度优先搜索函数（如果当前顶点的一条边指向被一个访问过的顶点，且二者颜色一致，则无法构成二分图） * @param g 图 * @param v 当前顶点 */ private void dfs(Graph g, int v){ marked[v] = true; for (int w : g.adj(v)){ if (!marked[w]){ color[w] = !color[v]; dfs(g, w); }else if (color[w] == color[v]) isTowColorable = false; } } public boolean isTowColorable() { return isTowColorable; } }  3.4 寻找路径\n判断两个顶点间是否有一条路径的问题在图的处理领域中十分重要的。使用深度优先搜索，我们可以较为简单的实现它。\n在DepthFirstPaths的实现中，基于DepthFirstSreach增加了 edgeTo[] 记录起点到各连通顶点的路径，它可以记录每一个顶点到起点的路径。为了做到这一点，在由边 v-w 第一次访问任意 w 时，将 edgeTo[w] 设为 v 来记住这条路径。edgeTo[v] 中又记录了上一个顶点，一直可以回溯到起点。这样在edgeTo[]中存储的就是一个以起点为根结点的树。通过连通的目标顶点我们总能找到一条指向起点的路径。具体实现如下。\npublic class DepthFirstPaths { private boolean[] marked; // 标记已访问过的顶点 private int[] edgeTo; // 记录起点到各连通顶点的路径 private final int s; // 起点 public DepthFirstPaths(Graph g, int s){ marked = new boolean[g.V()]; edgeTo = new int[g.V()]; this.s = s; dfs(g, s); } /** * 深度优先搜索函数 * @param g 图 * @param v 当前顶点 */ private void dfs(Graph g, int v){ marked[v] = true; for (int w : g.adj(v)){ if (!marked[w]){ edgeTo[w] = v; dfs(g, w); } } } /** * 查看顶点 v 是否与起点联通 * @param v 顶点 * @return 联通 true，不连通 false */ public boolean hasPathTo(int v){ return marked[v]; } /** * 若顶点 v 与起点联通，获取路径上的结点 * @param v 当前顶点 * @return 表示顶点路径的list集合 */ public List\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); for (int x = v; x != s; x = edgeTo[x]) path.add(x); path.add(s); return path; } }  测试用例\n用例输入------------------------------------------------------------ 13 13 0 5 4 3 0 1 9 12 6 4 5 4 0 2 11 12 9 10 0 6 7 8 9 11 5 3 用例代码------------------------------------------------------------ int s = 0, v = 6; //dfp test DepthFirstPaths dfp = new DepthFirstPaths(graph, s); List\u0026lt;Integer\u0026gt; path1= dfp.pathTo(v); System.out.print(\u0026quot;dfp \u0026quot;+s+\u0026quot;-\u0026gt;\u0026quot;+ v + \u0026quot; : \u0026quot; + s); for (int i = path1.size()-2; i \u0026gt;= 0; i--){ System.out.print(\u0026quot;-\u0026quot; + path1.get(i)); } 用例输出------------------------------------------------------------ dfp 0-\u0026gt;6 : 0-5-3-4-6  用例图示\n直接看测试用例输入输出难以验证程序的正确性，根据上图我们可以观察到，使用 DepthFirstPaths 找到的顶点 0-\u0026gt;6的路径: 0-5-3-4-6确实存在，程序是正确的。\n但是仔细观察，我们会发现找顶点 0-\u0026gt;6的路径，可以直接可以从0到6啊？上文提到过，深度优先算法访问顶点的顺序是根据 Graph 的 adj() 方法返回的顶点顺序来的，然后在次用例中可能 5 比 6 先返回。导致绕了一大圈才找到6。\n而且上述要求对于深度优先算法太为苛刻，本来就没有这方面的功能属性。要解决这个问题也就是：单点最短路径问题（给定顶点到起点的最短路径）。需要使用另一个经典算法 广度优先搜索 。\n4. 广度优先搜索 广度优先搜索（BFS）正是为了解决 单点最短路径问题 才被学者研究出来。它可以容易的找到连通顶点间的最短路径，这对使用图处理现实中的诸多问题起到了非常重大的作用。\n在程序中，搜索一幅图时遇到有多条边需要遍历的情况时，我们会选择其中一条并将其他通道留到以后再继续搜索。\n在深度优先搜索中，使用的是下压栈（方法递归）来放置还没有处理的边，当我们选取下一条边时自然是根据LIFO（先进后出）的规则取，取到的自然是最晚遇到的那一条边。这样就会一直往图的深处访问。\n而在广度优先搜索中我们想要找到顶点到起点的最短路径，就必须对取下一条边的规则重新定义。广度优先搜索是按照顶点到起点的距离来遍历顶点的，也就是说，首先遍历到起点距离为 1 的所有顶点，然后遍历到起点所有距离为 2 的所有顶点以此类推。这样就需要我们在选择下一条边处理时，选择最早遇到的那条边，而不是直接一直往图深处访问。这个顺序规则对应的就是 FIFO（先进先出）规则，实现FIFO我们只需要将遇到的边加入 队列 然后一条条取就行了。\n所以广度优先搜索，和深度优先搜索的区别就在于取下一条边的顺序规则。\n4.1 实现\nBreadthFirstPaths 与 DepthFirstPaths 都使用一个int[] edgeTo 来存储路径，除了控制边访问顺序的代码不同，其余代码几乎都是相同的。\nBreadthFirstPaths 的 bfs() 方法中使用了一个 Queue 队列来存放遇到的边。 首先会将起点加入队列，然后重复以下步骤直到队列为空：\n 取队列中的下一个顶点 v 并标记它；\n 将与 v 相邻的所有未被标记过的顶点加入队列。\n  由于需要处理的边都存放在了队列，bfs() 方法就不需要使用递归来处理访问。BreadthFirstPaths 的具体实现如下。\npublic class BreadthFirstPaths { private boolean[] marked; // 到达该顶点的最短路径是否已知 private int[] edgeTo; // 记录起点到各连通结点的最短路径 private final int s; // 起点 public BreadthFirstPaths(Graph g, int s){ marked = new boolean[g.V()]; edgeTo = new int[g.V()]; this.s = s; bfs(g, s); } /** * 广度优先搜索函数（使用队列控制搜索元素） * @param g 图 * @param s 起点 */ private void bfs(Graph g, int s){ Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); marked [s] = true; queue.offer(s); while (!queue.isEmpty()){ int v = queue.poll(); for (int w : g.adj(v)){ if (!marked[w]){ edgeTo[w] = v; marked[w] = true; queue.offer(w); } } } } /** * 查看当前顶点 v 是否与起点连通 * @param v 当前顶点 * @return 连通 true，不连通 */ public boolean hasPathTo(int v){ return marked[v]; } /** * 若顶点 v 与起点联通，获取路径上的结点 * @param v 当前顶点 * @return 表示顶点路径的list集合 */ public List\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); for (int x = v; x != s; x = edgeTo[x]) path.add(x); path.add(s); return path; } }  测试用例\n用例输入------------------------------------------------------------ 与 3.4 节一致 用例代码------------------------------------------------------------ int s = 0, v = 6; //bfp test BreadthFirstPaths bfp = new BreadthFirstPaths(graph, s); List\u0026lt;Integer\u0026gt; path2 = bfp.pathTo(v); System.out.print(\u0026quot;bfp \u0026quot;+s+\u0026quot;-\u0026gt;\u0026quot;+ v + \u0026quot; : \u0026quot; + s); for (int i = path2.size()-2; i \u0026gt;= 0; i--){ System.out.print(\u0026quot;-\u0026quot; + path2.get(i)); } 用例输出------------------------------------------------------------ bfp 0-\u0026gt;6 : 0-6  我们从输出可以看见，广度优先搜索选择了最短最优的路径，从0直接到6。\n广度优先搜索与深度优先搜索的区别从下图中可以更明显的看出：\n上图，显示了深度优先搜索和广度优先搜索处理含有250个顶点图的过程，左图为深度优先搜索，右图为广度优先搜索，它们清晰地展示了两种方法中搜索路径的不同。深度优先搜索不断深入图中并在栈中保存了所有分叉的顶点；广度优先搜索则像扇面一般扫描图，用一个队列保存访问过的最前端的顶点。深度优先搜索探索一幅图的方式是寻找离起点更远的顶点，只在碰到死胡同时才访问近处的顶点；广度优先搜索则会首先覆盖起点附近的顶点，只在临近的所有顶点都被访问了之后才向前进。\n符号图 在图算法实际的应用中，处理的很多问题是从现实的问题中抽象出一幅图。图的顶点往往是用字符串代指的。而且不会像 Graph 接受的输入会预先告知顶点数边数。为了用图的算法去更好的处理实际问题，我们需要将使用数字顶点的图Graph 数据类型扩展成字符串代指顶点的图，而且会根据输入来自动确定定点数，边数。\n在 SymbolGraph 符号图的实现中，使用 Graph 作为基础数据类型，使用一个符号表 HashMap 完成顶点字符串到顶点号的映射。使用一个 String[] 对应着HashMap 的反向索引，以顶点号作为索引，值为顶点名。有了着两个符号表我们可以轻松的根据顶点名得到顶点号，或者根据顶点号知道顶点名。\nHashMap 正向索引值为上一次元素添加后 HashMap 的元素数量。SymbolGraph 符号图的具体实现如下。\npublic class SymbolGraph { private HashMap\u0026lt;String, Integer\u0026gt; map; // 符号名 -\u0026gt; 索引 private String[] keys; // 索引 -\u0026gt; 符号名 private Graph graph; // 图 public SymbolGraph(BufferedReader reader, String sp) throws IOException { map = new HashMap\u0026lt;\u0026gt;(); String temp; // 初始化符号表，生成正向索引 while ((temp = reader.readLine()) != null) { String[] vertex = temp.split(sp); for (String s : vertex) { if (!map.containsKey(s)) map.put(s, map.size()); } } // 初始化反向索引 keys = new String[map.size()]; for (String name : map.keySet()) { keys[map.get(name)] = name; } graph = new Graph(map.size()); reader.reset(); // 添加边 while ((temp = reader.readLine()) != null) { String[] vertex = temp.split(sp); int v = map.get(vertex[0]); for (int i = 1; i \u0026lt; vertex.length; i++) graph.addEdge(v, map.get(vertex[i])); } } public boolean contains(String s){ return map.containsKey(s); } public int index(String s){ return map.get(s); } public String name(int v) { return keys[v]; } public Graph getGraph(){ return graph; } }  测试用例\n用例输入------------------------------------------------------------ JFK MCO ORD DEN ORD HOU DFW PHX JFK ATL ORD DFW ORD PHX ATL HOU DEN PHX PHX LAX JFK ORD DEN LAS DFW HOU ORD ATL LAS LAX ATL MCO HOU MCO LAS PHX 用例代码 ------------------------------------------------------------ File file = new File(\u0026quot;src/resources/route.txt\u0026quot;); InputStream in = new FileInputStream(file); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); reader.mark((int)(file.length()+1)); SymbolGraph graph = new SymbolGraph(reader, \u0026quot; \u0026quot;); System.out.println(graph.index(\u0026quot;PHX\u0026quot;)); System.out.println(graph.name(6) + \u0026quot;\\n----------------------------------------------\u0026quot;); String s = \u0026quot;JFK\u0026quot;, v = \u0026quot;LAS\u0026quot;; //dfp test DepthFirstPaths dfp = new DepthFirstPaths(graph.getGraph(), graph.index(s)); List\u0026lt;Integer\u0026gt; path1= dfp.pathTo(graph.index(v)); System.out.print(\u0026quot;dfp \u0026quot;+ s +\u0026quot;-\u0026gt;\u0026quot;+ s + \u0026quot; : \u0026quot; + s); for (int i = path1.size()-2; i \u0026gt;= 0; i--){ System.out.print(\u0026quot;-\u0026quot; + graph.name(path1.get(i))); } //bfp test BreadthFirstPaths bfp = new BreadthFirstPaths(graph.getGraph(), graph.index(s)); List\u0026lt;Integer\u0026gt; path2 = bfp.pathTo(graph.index(v)); System.out.print(\u0026quot;\\nbfp \u0026quot;+ s +\u0026quot;-\u0026gt;\u0026quot;+ s + \u0026quot; : \u0026quot; + s); for (int i = path2.size()-2; i \u0026gt;= 0; i--){ System.out.print(\u0026quot;-\u0026quot; + graph.name(path2.get(i))); } 用例输出------------------------------------------------------------ 6 PHX ---------------------------------------------- dfp JFK-\u0026gt;JFK : JFK-MCO-HOU-ORD-DEN-PHX-LAX-LAS bfp JFK-\u0026gt;JFK : JFK-ORD-DEN-LAS  用例图示\n上述用例输入的是根据一个小运输系统抽象出来的模型，具体的情况如上图所示。其中表示每个顶点的是美国机场的代码，连接它们的边则表示顶点之间的 航线。用例输入只有边而没有顶点数，边数。在用例代码中表示顶点也可以使用字符串来表示，更方便处理实际问题。\n根据虚线上的输出可以发现正向索引与反向索引对应良好。在虚线输出后分别使用了深度优先搜索，广度优先搜索，查询 JFK -\u0026gt; LAS 间的路径。深度优先搜索还是一如既往的头铁，找出了一条非常长的路径。而广度优先搜索则是不负众望找到了一条通过定点数最少的路径之一。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/",
	"title": "1. Binary-Search",
	"tags": [],
	"description": "",
	"content": " 二分查找 二分查找也称为折半查找（Binary Search），是一种效率较高的查找方法。它的一般查找过程为：首先，需要将待查的线性表按关键字排序，然后将表中间位置的元素的关键字与查找关键字比较。如果二者相等，则查找成功。如果不相等，则使用表的中间位置元素将表分为左右两个子表，查找关键字大于中间位置元素的关键字 -\u0026gt; 继续查询右子表；查找关键字小于中间元素的关键子 -\u0026gt; 继续查询左子表。重复以上过程直到查找到满足查询条件的元素，若最后细分到无法再划分子表时则没有此元素查询失败。由二分查找的原理我们很容易得出其时间复杂度为：lgN（以2为底）。\n1. 基于有序数组的二分查找 想要在一个数组查找到一个元素的索引，最普通的方法就是将数组遍历一遍，将元素的关键字逐个的与查找关键字比较，直到找到元素返回其索引。这种方法的时间复杂度是线性级别的，在数组长度非常大且处于最坏的情况时，可能是无法解决的。而二分法就将解决这个这个问题的时间复杂度降低到了对数级别。如果数组长度为：100000000000, 在最坏的情况下，前者需要循环访问数组：1000亿次，而后者只需要访问数组约：36.5412次。这简直是降维打击，让我们能在有限算力的计算机上解决更多问题。下面是一个基于有序数组二分查找的实现。\nJava\npublic class BinarySearch { //二分法查找元素的索引 public static int Search(int[] a, int key){ int lo=0, hi = a.length-1; while (lo \u0026lt;= hi){ int mid = lo + (hi-lo)/2; if (key \u0026gt; a[mid]) lo = mid + 1; else if (key \u0026lt; a[mid]) hi = mid - 1; //found else return mid; } //not found return -1; } }  可以看到基于有序数组的二分查找实现非常简单，只需要两个辅助指针即可完成。\n2.二分查找在实际问题中的应用 1.爱吃香蕉的珂珂(leetcode)\n珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。\n珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。\n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。\n示例 1：\n输入: piles = [3,6,7,11], H = 8 输出: 4  示例2：\n输入: piles = [30,11,23,4,20], H = 5 输出: 30  也就是说珂珂想要慢慢的吃香蕉，但是又想把所有香蕉吃完，我们需要找到哪个满足这两个条件的最合适的速度K。\n乍一看我们似乎无法将这个题目与二分查找关联起来。先抛开二分查找，我们快速的找一个简单暴力的方法：将所有可能的速度K都穷举一遍代入到问题中，最后求出最优解。K的范围的可能值显然为 [1, max(piles)]。最大的速度就是每次都可以将一堆香蕉吃完也就是max(piles)。\n哦豁，现在是不是有点灵光乍现，这不就是和上面那个遍历有序数组差不多吗？ 这时投入我们的二分查找优化算法，减少访问数组的次数,提升效率。具体解题如下：\nJava\nclass Solution { public int minEatingSpeed(int[] piles, int H) { int left = 1, right = getMax(piles); while(left \u0026lt;= right){ int mid = left + (right - left)/2; if(canEatAll(piles, mid, H)){ //能吃完(查询到) right = mid - 1; }else{ //不能吃完 left = mid + 1; } } return left; } //判断在当前速度k下，珂珂能否吃完所有香蕉 boolean canEatAll(int[] piles, int k, int H){ int time = 0; for(int n : piles){ time += timeOf(n, k); } return time \u0026lt;= H; } //给定速度k下，吃完数量n香蕉的时间 int timeOf(int n, int k){ return (n/k) + ((n % k \u0026gt; 0) ? 1 : 0); } //香蕉最多的堆的香蕉数 int getMax(int[] piles){ int max = 0; for(int n : piles){ max = Math.max(n, max); } return max; } }  这里的解题中二分查找的使用和上面一般的实现有一些区别，一般实现是默认数组元素不重复的，如果找到元素后就立即返回元素的索引。而这里珂珂吃香蕉，只要是大于等于答案速度的取值都可以让珂珂把香蕉吃完，也就相当于有许多满足查询条件的元素，也就相当于是元素重复了。\n而我们的珂珂想要慢慢的吃，也就是要满足条件的速度中最慢的那一个取值。所以我们需要找到满足条件最靠左的速度。所以在满足能吃完的条件时我们不能直接返回速度，而是将其左边子数组的最大索引赋值给右指针。然后在指针值不满足循环条件时返回左指针的值，也就是最慢能吃完香蕉的速度。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/",
	"title": "Algorithms",
	"tags": [],
	"description": "",
	"content": " Algorithms Notes "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/sorting/",
	"title": "Sorting",
	"tags": [],
	"description": "",
	"content": " Sort Notes "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/sorting/%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F/",
	"title": "1. Merge-Sort",
	"tags": [],
	"description": "",
	"content": " 并归排序 顾名思义，并归排序是排序算法的一种，它的主要特点及思想就是体现在 “并归” 二字。并归排序中的并归的含义是指，将两个有序的数组并归组合成一个更大的有序数组。\n而并归排序的思想就是将一个待排序数组（递归的）平均分割成两个子数组，然后分别给左右两个子数组排序，最后将排序结果并归起来，完成数组的排序。\n1. 自顶向下的并归排序 自顶向下的并归排序也被称为递归并归排序。递归实现的归并排序是算法设计中分治思想的典型应用。我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题： 将一个待排序数组（递归的）平均分割成两个子数组，两个子数组又递归的调用排序方法，直到递归到子数组只含一个元素。然后将二者并归就得到了一个含两个元素的有序数组。最后依次回溯并归直到待排序数组中没有子数组，完成排序。\nJava\npublic class Merge { //并归所需的辅助数组 private static int[] aux; /** * sort1 自顶向下的并归排序 * @param a 待排序数组 */ public static void sort1(int[] a) { //分配空间 aux = new int[a.length]; sort1(a, 0, a.length-1); } private static void sort1(int[] a, int lo, int hi) { //数组长度为1 if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; //排序左半边 sort1(a, lo, mid); //排序右半边 sort1(a, mid + 1, hi); //并归结果 merge(a, lo, mid, hi); } /** * sort2 自底向上的并归排序 * @param a 待排序数组 */ public static void sort2(int[] a){ int n = a.length; aux = new int[n]; for (int sz = 1; sz \u0026lt; n; sz = sz+sz){ for (int lo = 0; lo \u0026lt; n-sz; lo += sz+sz ){ merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); } } } //并归操作 private static void merge(int[] a, int lo, int mid, int hi) { int i = lo, j = mid + 1; //复制数组(a[lo...hi] -\u0026gt; aux[lo...hi]) for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; //并归元素到 a[lo...hi] 中 for (int k = lo; k \u0026lt;= hi; k++) { //左半边元素用尽 if (i \u0026gt; mid) a[k] = aux[j++]; //右半边元素用尽 else if (j \u0026gt; hi) a[k] = aux[i++]; //右半边当前元素大于左半边当前元素 else if (aux[j] \u0026gt; aux[i]) a[k] = aux[i++]; else a[k] = aux[j++]; } } }  2. 自底向上的并归排序 实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。这种实现方法比标准递归方法所需要的代码量更少。自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值 为1，每次加倍。\nJava\npublic class Merge { //并归所需的辅助数组 private static int[] aux; //sort2 自底向上的并归排序 private static void sort(int[] a){ int n = a.length; aux = new int[n]; for (int sz = 1; sz \u0026lt; n; sz = sz+sz){ for (int lo = 0; lo \u0026lt; n-sz; lo += sz+sz ){ merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); } } } //并归操作 private static void merge(int[] a, int lo, int mid, int hi) { int i = lo, j = mid + 1; //复制数组(a[lo...hi] -\u0026gt; aux[lo...hi]) for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; //并归元素到 a[lo...hi] 中 for (int k = lo; k \u0026lt;= hi; k++) { //左半边元素用尽 if (i \u0026gt; mid) a[k] = aux[j++]; //右半边元素用尽 else if (j \u0026gt; hi) a[k] = aux[i++]; //右半边当前元素大于左半边当前元素 else if (aux[j] \u0026gt; aux[i]) a[k] = aux[i++]; else a[k] = aux[j++]; } } }  3. 复杂度分析 并归排序时间复杂度的推导公式为：T(n) = 2T(2/n) + n , 并设：T(0)=T(1)=0\nT(2/n)为平分后两个子数组排序的时间复杂度，n为并归数组所需的时间。\n在初次递归的基础上进行第二次递归：T(n) = 2{2T(n/4) + (n/2)} + n = 2^2T(n/2^2) + 2n\n第三次递归：T(n) = 2^2{2T(n/2^3) + n/(2^2)} + 2n = 2^3 T(n/2^3) + 3n\n……\n假设递归到 m 次时，递归完成，则有：T(n) = 2^m T(n/2^m) + mn = 2^m T(1) + mn\n得到：T(n/2^m) = T(1) —\u0026gt; n = 2^m —\u0026gt; m = logn (默认以2为底)\n将 m = logn 代入 2^m T(1) + mn：T(n) = 2^(logn) T(1) + nlogn = n T(1) + nlogn = n + nlogn\n当n足够大时 nlogn 远大于 n 所以取：nlogn\n综上并归排序的时间复杂度为：O( nlogn )\n由于使用了一个辅助数组所以空间复杂度为：O( n )\n4. 优缺点 优点\n 时间复杂度为 O( nlogn ), 是基于比较的排序算法能达到的最好情况。\n 算法稳定，分别在最好情况以及最坏情况的时间复杂度都是 O( nlogn )。多用于对象的排序。\n  缺点\n 需要辅助数组，空间复杂度为O(n),在同类效率类似的算法中归并排序的空间复杂度略高。  "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/spring/spring-loc-container/",
	"title": "1. Spring loC Container",
	"tags": [],
	"description": "",
	"content": " 1. Spring 概述 Spring使创建Java企业应用程序变得容易。它提供了在企业环境中使用Java语言所需的一切，并支持Groovy和Kotlin作为JVM上的替代语言，并且可以根据应用程序的需求灵活地创建多种体系结构。从Spring Framework 5.1开始，Spring需要有JDK 8+（Java SE 8+）的开发运行环境，并提供对JDK 11 LTS的现成支持。\nSpring框架分为多个模块。应用程序可以根据其需求选择所需的模块。核心容器模块是Spring框架的核心，包括配置模型和依赖项注入机制。除此之外，Spring框架还为不同的应用程序体系结构提供了基础支持，包括消息传递，事务性数据和持久性以及Web。它还包括基于Servlet的Spring MVC Web框架，以及并行的Spring WebFlux反应式Web框架。\n2. Spring loC Container 概述 IoC (Inversion of Control) 翻译成中文称之为“控制反转”，为什么会叫控制反转呢？ 在我们以往的编程中，通常 new 一个类的实例，控制权往往都是由程序控制。而在使用Spring框架的应用程序中，这些工作都是交给 Spring loC Container 来做。由 Spring loC Container来负责实例化，定位，配置和注入应用程序的对象以及对象间的依赖关系。对于对象的控制权由程序员转向了程序（Spring loC Container), 所以才会叫做控制反转。\n在org.springframework.beans和org.springframework.context包是Spring框架的IoC容器的基础核心。 BeanFactory 容器提供了一种高级配置机制，能够管理任何类型的对象。 ApplicationContext 是的子接口BeanFactory。它增加了：\n 与Spring的AOP功能轻松集成 消息资源处理（用于国际化） 活动发布 应用层特定的上下文，例如WebApplicationContext 用于Web应用程序中的。  简而言之，BeanFactory提供了配置框架和基本功能，并 ApplicationContext 增加了更多针对企业的功能。该 ApplicationContext 是一个完整 BeanFactory 的超集。\n由于 BeanFactory 逐渐被弃用，我们着重了解org.springframework.context.ApplicationContext，由于它是BeanFactory的超集，ApplicationContext接口也代表Spring IoC容器，并负责实例化，配置和组装Bean。容器通过读取配置元数据来获取有关要实例化，配置和组装哪些对象的指令。配置元数据可以用XML，Java批注或Java代码表示。它使您能够表达组成应用程序的对象以及这些对象之间的丰富相互依赖关系。ApplicationContext 所表示的 spring 容器在整个spring框架中的作用如下图所示。\nSpring 工作原理\nspring 容器会将你配置元数据注入到应用程序中的类对象中，因此在 ApplicationContext 创建和初始化后，应用程序系统将是配置完全且可运行的。\n3. 配置元数据（Configuration Metadata） 如上图所示，Spring IoC容器使用一种形式的配置元数据。这个配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器在应用程序中实例化，配置和组装对象。配置元数据可以用3种方法提供给 spring 容器：\n 基于XML的配置：传统的最简单直观的的方法。 基于注释的配置：Spring 2.5引入了对基于注释的配置元数据的支持。 基于Java的配置：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring Framework的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外部的bean。  Spring配置由容器必须管理的至少一个（通常是一个以上）bean定义组成。基于XML的配置元数据将这些bean配置为顶级元素内的元素。Java配置通常@Bean在@Configuration类中使用带注释的方法。\n基于XML配置的例子：\n\u0026lt;beans\u0026gt; \u0026lt;import resource=\u0026quot;services.xml\u0026quot;/\u0026gt; \u0026lt;import resource=\u0026quot;resources/messageSource.xml\u0026quot;/\u0026gt; \u0026lt;import resource=\u0026quot;/resources/themeSource.xml\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;bean1\u0026quot; class=\u0026quot;...\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;bean2\u0026quot; class=\u0026quot;...\u0026quot;/\u0026gt; \u0026lt;/beans\u0026gt;  在前面的例子中，id属性是用于指定单个bean的唯一标识符。class属性定义Bean的类型。外部 bean 的定义是从三个文件加载： services.xml，messageSource.xml，和themeSource.xml。所有位置路径是相对于定义文件为基准，因此services.xml必须在同一个目录或类路径位置作为其它bean文件的定位基准，而 messageSource.xml并themeSource.xml必须在resources基准文件的位置下方的位置。第二个 import 与第三个 import都是可用的，但是第三个使用了一个斜杠，这是不必要的虽然会被忽略掉。根据Spring Schema，导入的文件的内容（包括顶层元素）必须是有效的XML bean定义。\n其它的两种配置方式涉及较多知识点后面用专门的一篇博客记录。\n4. 使用 Spring loC Container 前面我们已经详细的介绍了 ApplicationContext 就是代表一个 Spring loC 容器，我们想要使用它就首先需要将其实例化。由于 ApplicationContext 是一个接口，其有多种实例化方式，最常见的有三种方式，如下：\n FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。 ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。 WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。  ApplicationContext 实例化后我们就可以用它来管理，调用应用程序种的 bean 对象，下面是一个使用 ClassPathXmlApplicationContext 类实例化 ApplicationContext 并获取bean对象的例子。\nHelloBean.java 文件内容：\npackage com.example.spring.bean; public class HelloBean { private String message; public void setMessage(String message) { this.message = message; } public void showMessage(){ System.out.println(\u0026quot;Message : \u0026quot;+message); } }  mainAPP.java 文件内容：\npackage com.example.spring; import com.example.spring.bean.HelloBean; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainAPP { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;Bean.xml\u0026quot;); HelloBean helloBean1 = (HelloBean) context.getBean(\u0026quot;helloBean\u0026quot;); helloBean1.showMessage(); } }  Bean.xml 文件内容：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;helloBean\u0026quot; class=\u0026quot;com.example.spring.bean.HelloBean\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;message\u0026quot; value=\u0026quot;Hello Spring!\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  输出结果：\nMessage : Hello Spring!  由输出结果可知，我们在 mainApp 文件中获取的HelloBean类对象是已经初始化完成的，然而我们编写的代码内并没有去初始化 helloBean1 这个对象，这就是 Spring 容器可以为我们做的最要事情之一。\n最后由于 BeanFactory 是以前经常用到的一个代表 spring 容器的接口，但由于其已被逐渐弃用，要尽可能避免使用，除非有特殊要。如果一定要用，可以用如下方式实例化 BeanFactory。\n在 mainAPP.java 文件上追加：\npackage com.example.spring; import com.example.spring.bean.HelloBean; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.support.BeanDefinitionReader; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.DefaultListableBeanFactory; import org.springframework.beans.factory.xml.XmlBeanDefinitionReader; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.Resource; public class MainAPP { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;Bean.xml\u0026quot;); HelloBean helloBean1 = (HelloBean) context.getBean(\u0026quot;helloBean\u0026quot;); Resource resource = new ClassPathResource(\u0026quot;Bean.xml\u0026quot;); BeanFactory factory = new DefaultListableBeanFactory(); BeanDefinitionReader bdr = new XmlBeanDefinitionReader((BeanDefinitionRegistry) factory); bdr.loadBeanDefinitions(resource); HelloBean helloBean2 = (HelloBean) factory.getBean(\u0026quot;helloBean\u0026quot;); helloBean1.showMessage(); helloBean2.showMessage(); } }  输出结果：\nMessage : Hello Spring! Message : Hello Spring!  "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/springmvc/springmvc-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
	"title": "1. SpringMVC 环境搭建",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
	"title": "1. Mybatis工作原理",
	"tags": [],
	"description": "",
	"content": " 1. Mybatis 简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n2. Mybatis工作原理 Mybatis 是一个Java框架，它的工作过程中一定包含了许多对象的构造和销毁，对象是面向对象编程的最重要的机制。了解 Mybatis 框架中的一些关键对象如何构造产生以及销毁，就相当于理解了 Mybatis 的工作原理。Mybatis工作原理可以用如下流程图进行说明。\n图中步骤流程说明：\n 1.读取 mybatis-config.xml 配置文件：mybatis-config.xml 为 Mybatis 的全局配置文件，文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。\n 2.加载映射器文件：映射器文件即Sql映射器文件，该文件中配置了操作数据库的Sql语句，需要在Mybatis配置文件 mybatis-config.xml 文件中声明加载。mybatis-config.xml 文件可以加载多个映射文件，每个映射文件一般对应数据库的一张数据表。\n 3.构造会话工厂对象：Mybatis根据其核心配置信息构建 SqlSessionFactory 对象。SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。\n 4.构造会话对象：SqlSession 会话对象由 SqlSessionFactory 会话工厂对象创建，该对象包含执行SQL语句的所有方法。SqlSession 的实例不是线程安全的， 每个线程都应该有它自己的 SqlSession 实例。\n 5.Executor 执行器：Mybatis 底层定义了一个 Executor 接口来操作数据库， 它根据 SqlSession 对象传递的参数动态的生成需要执行的 Sql 语句，同时负责查询缓存的维护。\n 6.MappedStatement对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数。该参数是对映射信息的封装，用于存储要映射的 Sql 语句的 id 等参数信息。\n 7.输出参数映射：输入的参数类型可以是 Map，List 等集合类型，也可以是Java的基本数据类型和pojo类型。输入参数过程类似于 JDBC 对 PreParedStatement 对象设置参数的过程。\n 8.输出结果类型：输出结果类型可以是 Map，List 等集合类型，也可以是Java的基本数据类型和pojo类型。输出结果映射类似于JDBC 对结果集的解析过程。\n  "
},
{
	"uri": "https://compass-ak.gitee.io/android/activity/activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
	"title": "1.  Activity生命周期",
	"tags": [],
	"description": "",
	"content": " 1. Activity简介 Activity 是一个Android应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。\n一个应用通常由多个彼此松散联系的 Activity 组成。 一般会指定应用中的某个 Activity 为“主”Activity，即首次启动应用时呈现给用户的那个 Activity。 而且每个 Activity 均可启动另一个 Activity，以便执行不同的操作。\n2. Activity生命周期 所谓Activity的生命周期就是一个Activity从创建到销毁的过程，这整个过程都是由Android系统处理，我们一般不能直接知道Activity处于哪个生命周期，但是和其他具有生命周期的对象一样，当Activity进入生命周期的每个阶段Android系统都会调用其特定的方法，以方便我们来管理Activity，以及在Activity的各个生命周期执行必要的相关操作。例如：在Activity刚创建时，需要设置页面布局，在Activity被停止时要释放网络或数据库连接，这种比较消耗系统资源的对象。\n以下的Activity内的方法包扩了每一个Activity基本生命周期方法。\npublic class ExampleActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // The activity is being created. } @Override protected void onStart() { super.onStart(); // The activity is about to become visible. } @Override protected void onResume() { super.onResume(); // The activity has become visible (it is now \u0026quot;resumed\u0026quot;). } @Override protected void onPause() { super.onPause(); // Another activity is taking focus (this activity is about to be \u0026quot;paused\u0026quot;). } @Override protected void onStop() { super.onStop(); // The activity is no longer visible (it is now \u0026quot;stopped\u0026quot;) } @Override protected void onDestroy() { super.onDestroy(); // The activity is about to be destroyed. } }\t 这些方法共同定义Activity的整个生命周期，我们可以根据需求去实现相应的方法，来监控Activity的生命周期，以及执行必要操作。\n Activity的整个生命周期发生在onCreate()与onDestroy()方法的调用之间，我们可以在onCreate()方法中执行全局的状态设置(例如定义布局)，在onDestroy()中释放此Activity所消耗的所有系统资源。\n Activity的可视生命周期发生在onStart()与onStop()方法的调用之间，这段时间的Activity是可见的，且用户可以与其交互。由于用户可能反复切换Activity，onStart()与onStop()方法可能会被多次调用。\n Activity的前台生命周期发生在onResume()与onPause()方法调用之间，在这段时间Activity位于所有Activity之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 我们可以实现onPause()在用户离开Activity保存页面的信息，（特定情况）例如用户在可输入文本框EditText内输入的信息。实现onResume()来读取信息填入EditText，使用户获得流畅的体验。由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。\n  下图说明了Activity 各个生命周期方法调用的顺序，以及其间的各种循环。\n下表详细的列出了相同的生命周期回调方法，其中对每一种回调方法做了更详细的描述，并说明了每一种方法在 Activity 整个生命周期内的位置，包括在回调方法完成后系统能否终止 Activity。\n   方法 说明 是否能事后终止？ 后接     onCreate() 首次创建 Activity 时调用。 您应该在此方法中执行所有正常的静态设置 — 创建视图、将数据绑定到列表等等。 系统向此方法传递一个 Bundle 对象，其中包含 Activity 的上一状态，不过前提是捕获了该状态始终后接 onStart()。 否 onStart()   onRestart() 在 Activity 已停止并即将再次启动前调用。始终后接 onStart() 否 onStart()   onStart() 在 Activity 即将对用户可见之前调用。如果 Activity 转入前台，则后接onResume()，如果 Activity 转入隐藏状态，则后接 onStop()。 否 onResume() 或 onStop()   onResume() 在 Activity 即将开始与用户进行交互之前调用。 此时，Activity 处于 Activity 堆栈的顶层，并具有用户输入焦点。始终后接 onPause()。 否 onPause()   onPause() 当系统即将开始继续另一个 Activity 时调用。 此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。 它应该非常迅速地执行所需操作，因为它返回后，下一个 Activity 才能继续执行。如果 Activity 返回前台，则后接 onResume()，如果 Activity 转入对用户不可见状态，则后接 onStop()。 是 onResume() 或 onStop()   onStop() 在 Activity 对用户不再可见时调用。如果 Activity 被销毁，或另一个 Activity（一个现有 Activity 或新 Activity）继续执行并将其覆盖，就可能发生这种情况。如果 Activity 恢复与用户的交互，则后接 onRestart()，如果 Activity 被销毁，则后接 onDestroy()。 是 onRestart()或onDestroy()   onDestroy() 在 Activity 被销毁前调用。这是 Activity 将收到的最后调用。 当 Activity 结束（有人对 Activity 调用了 finish()），或系统为节省空间而暂时销毁该 Activity 实例时，可能会调用它。 您可以通过 isFinishing() 方法区分这两种情形。 是 无     在是否能在事后终止？列中标记为“否”的方法可从系统调用它们的一刻起防止承载 Activity 的进程被终止。 因此，在从 onPause() 返回的时间到 onResume() 被调用的时间，系统可以终止 Activity。在 onPause() 被再次调用并返回前，将无法再次终止 Activity。\n "
},
{
	"uri": "https://compass-ak.gitee.io/android/activity/",
	"title": "Activity",
	"tags": [],
	"description": "",
	"content": " Activity Activity Notes Android Core1\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/",
	"title": "Web",
	"tags": [],
	"description": "",
	"content": " Java Web Lorem Ipsum.\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/",
	"title": "web 基础",
	"tags": [],
	"description": "",
	"content": " Chapter 3.1 Java Web 基础 "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F/",
	"title": "1. web服务器原理（网络程序）",
	"tags": [],
	"description": "",
	"content": "## []()##web服务器原理 我们现在每天浏览网页，浏览器向服务器发送请求，服务器中的web服务器来处理来至全世界各地的请求信息。web服务器请求并返回文档信息，web服务器的基本原理是怎样的呢？\n我们可以这样分析，web服务器是用来处理请求信息，返回服务器信息资源。处理信息，返回信息。这不就是程序的功能吗？\n没错web服务器就是许多网络程序的集合，下面用一个网络程序例子来深入了解一下web服务器的工作原理，网络程序代码如下。\npackage my_java_network_program; import java.net.*; import java.io.*; public class Server { public static void main(String[] args) throws IOException { ServerSocket server=new ServerSocket(8888); Socket sock=server.accept(); FileInputStream in=new FileInputStream(\u0026quot;文件路径\\\\index.html\u0026quot;); OutputStream out=sock.getOutputStream(); int len=0; byte buffer[]=new byte[1024]; while((len=in.read(buffer))\u0026gt;0) { out.write(buffer,0,len); } in.close(); out.close(); sock.close(); server.close(); } }  程序用的是Java网络编程的知识。运行程序后，在浏览器地址栏输入：http://localhost:8888/ 就可访问文件路径中的 index.html 的网页类容。如果是在另一台机器访问，只需将localhost换成你机器的IP地址就可访问。访问结果如下所示：\n那么，其实web服务器就是向上面的网络程序的集合，来处理发送到服务器的请求信息，并返回信息资源。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/graphs/digraph/",
	"title": "2. Digraph",
	"tags": [],
	"description": "",
	"content": " 有向图 -图片资料来自 Algorithms, 4th Edition\n有向图中的有向是指图中每一条边都是有向的，每一条边连接的两个顶点都是一个有序对，它们的邻接性是单向的。能从 v-\u0026gt;w ，不一定能从 w-\u0026gt;v。这是有向图与无向图的本质区别，这种区别导致了两种图处理算法上的巨大差异。\n1. 术语表 学习有向图的处理算法我们，需要了解一些定义和术语。如下表：\n   术语 条件（释义）     有向图 一幅有方向性的图，由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。   出度 顶点指出边的总数   入度 指向该顶点边的总数   有向路径 由一系列顶点组成，对于其中的每一个顶点都存在一条有向边从它指向序列中的下一个顶点   有向环 至少含有一条边且起点终点相同的有向路径   简单有向环 是一条不含有重复顶点的环（除起点和终点相同）   长度（路径，环） （路径，环）所包含的边数   有向无环图（DAG） 不含环的有向图   强连通 有向图中的两顶点相互可达,称两顶点强连通。如果有向图所有顶点强连通则图强连通    2. 有向图数据类型 有向图虽然在逻辑上比无向图中多出了许多限定条件，但是其数据类型的实现更简单。由于边是有向的，所以我们用邻接表表示边时，只会出现一次。具体实现细节如下：\npublic class Digraph{ private final int V; // 顶点数 private int E; // 边数 private Node[] adj; // 邻接表 /** * 邻接表结点静态内部类 */ private static class Node{ int vertex; // 顶点 Node next; // 下一个元素的引用 Node(){} Node(int vertex, Node next){ this.vertex = vertex; this.next = next; } } public Digraph(int V){ this.V = V; this.E = 0; this.adj = new Node[V]; // 创建邻接表 } public Digraph(BufferedReader reader) throws IOException { this(Integer.parseInt(reader.readLine())); // 读取 V int E = Integer.parseInt(reader.readLine()); // 读取 E for (int i = 0; i \u0026lt; E; i ++){ String str = reader.readLine(); String[] edge= str.split(\u0026quot; \u0026quot;); int v = Integer.parseInt(edge[0]); int w = Integer.parseInt(edge[1]); addEdge(v, w); // 添加边 } } /** * 添加一条边 v -\u0026gt; w * @param v 顶点1 * @param w 顶点2 */ public void addEdge(int v, int w){ Node first = adj[v]; adj[v] = new Node(w, first); // 将顶点w添加到顶点v的链表中 E++; } /** * 获取与顶点 v 邻接的所有顶点 * @param v 顶点 * @return 邻接顶点set集合 */ public Set\u0026lt;Integer\u0026gt; adj(int v){ Node node = adj[v]; Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while (node != null){ set.add(node.vertex); node = node.next; } return set; } /** * 获取当前图的反向图 * @return 反向图 */ public Digraph reverse(){ Digraph dr = new Digraph(V); for (int v = 0; v \u0026lt; V; v++){ for (int w : adj(v)) dr.addEdge(w, v); } return dr; } public int V(){ return V;} public int E(){ return E;}  上述实现与 Graph 无向图数据类型的实现基本相同，更改了addEdge() 方法，只插入一个结点。增加了一个 reverse() 方法返回图的反向图（将所有边的方向反转）。\n3. 有向图中的可达性 能使用一种算法判断有向图中的两个顶点间是否存在一条有向路径是一个非常切实的需求，因为图只要稍微一复杂凭肉眼就很难判断顶点是否可达另一顶点。\n这个问题又叫做：点单可达性 （给定一幅有向图和一个起点 s，“是否存在一条从 s 到达给定顶点 v 的有向路径？”）解决这个有向图的问题我们只需要将 DepthFirstSearch 稍作改动，将 Graph 数据类型替换位 Digraph 数据类型即可。DirectedDFS具体实现如下：\npublic class DirectedDFS { private boolean[] marked; // 标记已访问过的顶点 private int count; // 与起点连通的结点数 public DirectedDFS(Digraph g, int s){ marked = new boolean[g.V()]; dfs(g, s); } public DirectedDFS(Digraph g, Iterable\u0026lt;Integer\u0026gt; sources){ marked = new boolean[g.V()]; for (int s : sources) if (!marked[s]) dfs(g, s); } /** * 深度优先搜索函数 * @param g 图 * @param v 当前顶点 */ private void dfs(Digraph g, int v){ marked[v] = true; count++; for (int w : g.adj(v)) if (!marked[w]) dfs(g, w); } /** * 查看顶点 w 是否与起点联通 * @param w 顶点 * @return 联通 true，不连通 false */ public boolean marked(int w){ return marked[w]; } /** * 获取与起点联通的结点数 * @return 结点数 */ public int count(){ return count; } }  多点可达性的一个重要的实际应用是在典型的内存管理系统中，包括许多 Java 的实现。在一幅有向图中，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。这个模型很好地表现了运行中的 Java 程序的内存使用状况。在程序执行的任何时候都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收以便释放内存。\n有时候找到一条顶点间的有向路径还不能满足我们的需求，我们希望能找到连接两个顶点有向路径中最短的那一条。 看到最短是不是马上就想到了 广度优先搜索，我们只需要给 breadthFirstPaths 添加一个接受有向图参数构造函数和bfs()方法, 方法内容与无向图一模一样。我们就可以找到两个连通顶点间最短的有向路径（由于无向图与有向图的数据表示与无向图没有区别，只是在逻辑上有区别）。构造函数，bfs()函数如下：\n public BreadthFirstPaths(Digraph g, int s){ marked = new boolean[g.V()]; edgeTo = new int[g.V()]; this.s = s; bfs(g, s); } /** * 广度优先搜索函数（使用队列控制搜索元素） * @param g 有向图 * @param s 起点 */ private void bfs(Digraph g, int s){ Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); marked [s] = true; queue.offer(s); while (!queue.isEmpty()){ int v = queue.poll(); for (int w : g.adj(v)){ if (!marked[w]){ edgeTo[w] = v; marked[w] = true; queue.offer(w); } } } }  4. 环和有向无环图 在和有向图相关的实际应用中，有向环特别的重要。没有计算机的帮助，在一幅普通的有向图中找出有向环可能会很困难。从原则上来说，一幅有向图可能含有大量的环；在实际应用中，我们一般只会重点关注其中一小部分，或者只想知道它们是否存在。\n4.1 调度问题\n我们经常会碰到这样一个问题：为一组需要完成的任务排好执行顺序序，而且任务间是有依赖关系的，有些任务必须在另一任务完成的前提下才能进行。这个时候我们可以将问题抽象成一幅有向图，每一个任务为一个顶点，有向边为任务间的依赖。例如大学生选修课程的问题，抽象出来的一幅图如下所示：\n课程有向图\n这时学生就需要根据课程间的依赖关系，确定一个合理的顺序修完课程。这也就是 拓扑排序 的功能\n4.2 环的检测\n在解决任务的调度问题时，抽象出的有向图是不能有环的。假设出现了一个有3个顶点的环，顶点分别为a，b，c。b 执行前需要 a 执行完，c 执行前又需要 b 执行完，而 a 执行又需要 c 执行完。这在我们这个纬度显然是无法同时满足的。所以我们使用图来解决任务调度排序的问题时，需要先检测抽象出的图是否含有环。如果含有环，那么就说明有些任务的划分是不合理的。\n在一幅有向图中，环的数量很有可能时指数级别的。我们检测是否存在环就只需要找出一个就可以了。换句话说就是我们需要确定有向图是一幅有向无环图（DAG）才可以对其进行拓扑排序，完成对任务的排序。\n判断图中是否存在环，这是深度优先搜索的拿手本领。基于深度优先搜索的实现的 DirectedCycle 如下。\npublic class DirectedCycle { private boolean[] marked; // 标记已访问过的顶点 private int[] edgeTo; // 记录起点到各连通顶点的路径 private List\u0026lt;Integer\u0026gt; cycle;// 存放发现的有向环的所有顶点 private boolean[] onStack; // 递归调用的栈上的所有顶点 public DirectedCycle(Digraph g){ onStack = new boolean[g.V()]; marked = new boolean[g.V()]; edgeTo = new int[g.V()]; for (int v = 0; v \u0026lt; g.V(); v++) if (!marked[v]) dfs(g, v); } private void dfs(Digraph g, int v){ onStack[v] = true; marked[v] = true; for (int w : g.adj(v)) { if (hasCycle()) return; else if (!marked[w]) { edgeTo[w] = v; dfs(g, w); } else if (onStack[w]) { //发现环，装入环所有顶点 cycle = new ArrayList\u0026lt;\u0026gt;(); for (int i = v; i != w; i = edgeTo[i]) { cycle.add(i); } cycle.add(w); cycle.add(v); } } onStack[v] = false; } public boolean hasCycle(){ return cycle != null; } public List\u0026lt;Integer\u0026gt; cycle() { Collections.reverse(cycle); return cycle; }  该类为标准的递归 dfs() 方法添加了一个布尔类型的数组 onStack[] 来保存递归调用期间栈上的所有顶点。当它找到一条边 v → w 且 w 在栈中时，它就找到了一个有向环。环上的所有顶点可以通过edgeTo[] 中的链接得到。\n4.3 拓扑排序\n定义：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。\n显然根据拓扑排序的定义，我们设计一种算法求出图顶点的拓扑排序，就相当于得到了这些顶点所对应任务的一种合理的排序可能，解决上文提到的任务调度的问题。\n我们想要得到一种顶点的顺序，可以使用深度优先搜索访问每一个结点，然后将结点加入队列即可。但是在什么时候将结点加入队列是一个关键问题，它可以决定执行后得到的排序的性质。一般情况下我们关心 3 种顶点的顺序：\n 前序：在递归访问顶点前加入队列。\n 后序：在递归访问顶点后加入队列。\n 逆后序：后序顺序的逆序。（拓扑排序）\n  基于深度优先搜索的顶点排序类：DepthFirstOrder 如下。实现了 pre(),post(), reversePost()。可以获得基于深度优先遍历图顶点的前序序列，后序序列，逆后序序列。\npublic class DepthFirstOrder { private boolean[] marked; // 标记已访问过的顶点 private ArrayList\u0026lt;Integer\u0026gt; pre; // 前序遍历顶点排列 private ArrayList\u0026lt;Integer\u0026gt; post;// 后序遍历顶点排列 public DepthFirstOrder(Digraph g){ pre = new ArrayList\u0026lt;\u0026gt;(); post = new ArrayList\u0026lt;\u0026gt;(); marked = new boolean[g.V()]; for (int s = 0; s \u0026lt; g.V(); s++) if (!marked[s]) dfs(g, s); } /** * 深度优先搜索函数 * @param g 图 * @param v 当前顶点 */ private void dfs(Digraph g, int v){ pre.add(v); marked[v] = true; for (int w : g.adj(v)) { if (!marked[w]) dfs(g, w); } post.add(v); } public List\u0026lt;Integer\u0026gt; pre(){ return pre; } public List\u0026lt;Integer\u0026gt; post() { return post; } public List\u0026lt;Integer\u0026gt; reversePost(){ Collections.reverse(post); return post; } }  在做了上文的有向环检测，有向图顶点排序后，实现拓扑排序就非常简单了。因为拓扑排序使用的就是：基于深度优先搜索遍历顶点的后逆序。我们直接写一个测试用例，以4.1的图为输入，输出其拓扑排序。\n-------------------------------------用例输入------------------------------------- Algorithms/Theoretical CS/Databases/Scientific Computing Introduction to CS/Advanced Programming/Algorithms Advanced Programming/Scientific Computing Scientific Computing/Computational Biology Theoretical CS/Computational Biology/Artificial Intelligence Linear Algebra/Theoretical CS Calculus/Linear Algebra Artificial Intelligence/Neural Networks/Robotics/Machine Learning Machine Learning/Neural Networks -------------------------------------用例代码------------------------------------- @Test public void TopologicalTest() throws IOException { File file = new File(\u0026quot;src/resources/course.txt\u0026quot;); InputStream in = new FileInputStream(file); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); reader.mark((int)(file.length()+1)); SymbolDigraph digraph = new SymbolDigraph(reader,\u0026quot;/\u0026quot;); DirectedCycle cycleFinder = new DirectedCycle(digraph.getGraph()); if (!cycleFinder.hasCycle()) { DepthFirstOrder dfs = new DepthFirstOrder(digraph.getGraph()); List\u0026lt;Integer\u0026gt; topological = dfs.reversePost(); for (int v : topological){ System.out.println(v + \u0026quot;--\u0026quot; + digraph.name(v)); } } } -------------------------------------用例输出------------------------------------- 9--Calculus 8--Linear Algebra 4--Introduction to CS 5--Advanced Programming 0--Algorithms 3--Scientific Computing 2--Databases 1--Theoretical CS 7--Artificial Intelligence 12--Machine Learning 11--Robotics 10--Neural Networks 6--Computational Biology  在测试用例代码中，首先判断了一下图是否含有环，然后再进行拓扑排序。再实际的其他许多问题上都是需要这样的流程的。\n根据用例输出的序列，与4.1图（图中标号根据输入得出）比较发现是满足拓扑排序的条件，所有的有向边均从排在前面的元素指向排在后面的元素。\n5. 有向图的强连通性 在术语表中我们提到了有向图的强连通：有向图中两顶点相互可达则称它们为强连通。若图中所有顶点强连通则有向图为强连通有向图。\n环与顶点的强连通具有密切联系。 实际上，若有向图的两顶点强连通它们必定会在一个有向环中。 最简单只含两个顶点的图，两顶点强连通就是一个环。其他复杂的情况只是在这个环中增加顶点而已。\n5.1 强连通分量\n有向图的强连通分量与无向图的连通分量定义类似：有向图的一个强连通分量就是它的一个极大强连通子图。\n与连通分量类似，强连通分量的划分也是基于顶点的，而不是基于边。因为有些边会同时属于多个强连通分量。\n识别有向图中的强连通分量有什么作用呢？我们计算的图都是由一些实际的问题抽象出来的。如果有向图中几个强连通的顶点构成一个连通分量，哪它们所映射到的事物之间是不是也有某种关联？可以被这种关联划分为一类。这就是强连通分量的作用。\n例如，强连通分量能够帮助教科书的作者决定哪些话题应该被归为一类，帮助程序员组织程序的模块，或帮助网络工程师将网络中数量庞大的网页分为多个大小可以接受的部分分别进行处理等等。\n5.2 Kosaraju 算法\n由于计算有向图的强连通分量有诸多用处，高效的计算出有向图的强连通分量是一个很值得研究的问题。经过先驱的努力，Kosaraju 算法就可以高效的完成任务。\nKosaraju 算法的基本流程为：\n 在给定一幅有向图 G 中，计算其反向图 G^R 的拓扑排序（逆后序）。\n 根据得到的拓扑排序顶点序列，对 G 进行标准的深度优先搜索访问顶点。\n 在构造函数中，所有在同一个递归 dfs() 调用中被访问到的顶点都在同一个强连通分量中。以发现顺序-1为id记录强连通分量（与无向图连通分量计算的CC类似）\n  其基本实现如下：\npublic class KosarajuSCC { private boolean[] marked; // 标记已访问过的顶点 private int[] id; // 顶点对应索引，值为连通分量的id private int count; // 连通分量数 public KosarajuSCC(Digraph g){ marked = new boolean[g.V()]; id = new int[g.V()]; // 使用图的后逆序遍历顶点，以顶点作为起点搜索图 DepthFirstOrder order = new DepthFirstOrder(g.reverse()); for (int s : order.reversePost()) { System.out.println(s); if (!marked[s]) { dfs(g, s); count++; } } } private void dfs(Digraph g, int v){ marked[v] = true; id[v] = count; for (int w : g.adj(v)) if (!marked[w]) dfs(g, w); } public boolean stronglyConnected(int v, int w){ return id[v] == id[w]; } public int id(int v){ return id[v]; } public int count(){ return count; } }  Kosaraju 算法的实现很简单，但是其正确性很难直观的看出来。就需要一个严谨的证明去证明其正确性。\n证明：\n 首先要用反证法证明“每个和 s 强连通的顶点 v 都会在构造函数调用的 dfs(G,s) 中被访问到”。假设有一个和 s 强连通的顶点 v 不会在构造函数调用的 dfs(G,s) 中被访问到。因为存在从 s 到 v 的路径，所以 v 肯定在之前就已经被标记过了。但是，因为也存在从 v 到s 的路径，在 dfs(G,v) 调用中 s 肯定会被标记，因此构造函数应该是不会调用 dfs(G,s) 的。矛盾。 其次，要证明“构造函数调用的 dfs(G,s) 所到达的任意顶点 v 都必然是和 s 强连通的”。设 v 为 dfs(G,s) 到达的某个顶点。那么， G 中必然存在一条从 s 到 v 的路径，因此只需要证明 G 中还存在一条从 v 到 s 的路径即可。这也等价于 G^R 中存在一条从 s 到 v 的路径，因此只需要证明在 G^R 中存在一条从 s 到 v 的路径即可。证明的核心在于，按照逆后序(拓扑排序：所有的有向边均从排在前面的元素指向排在后面的元素)进行的深度优先搜索意味着，在 G^R 中进行的深度优先搜索中，dfs(G,v) 必然在 dfs(G,s) 之前就已经结束了，这样 dfs(G,v) 的调用就只会出现两种 情况： 1. 调用在 dfs(G,s) 的调用之前（并且也在 dfs(G,s) 的调用之前结束）；\n2. 调用在 dfs(G,s) 的调用之后（并且也在 dfs(G,s) 的结束之前结束）。\n第一种情况是不可能出现的，因为在 G^R 中存在一条从 v 到 s 的路径；而第二种情况则说明 G^R中存在一条从 s 到 v 的路径。证毕。\n 从下面这张图可以非常直观的看到 Kosaraju 算法排序的过程。\nKosaraju 算法运算过程\n左边得到反向图 G^R 的拓扑排序，右边根据 G^R 的拓扑排序访问顶点找出所有的强连通分量。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/",
	"title": "2. Binary-Search-Tree",
	"tags": [],
	"description": "",
	"content": " 二叉查找树 我们都知道在一定程度上，程序 = 算法 + 数据结构。抛开数据结构说算法；抛开算法说数据结构，都是不太妥当的。而衡量一种数据结构的优略，一是看具体的问题需求，二是看其插入，删除排序等各个方面的性能。\n在二分查找中我们使用的经典的数组实现，在查询的效率上直接达到了 lgN 对数级别的效率。但是数组这种数据结构在插入元素时，就有些力不从心了。在最坏的情况下使用基于二分查找的数组插入一个元素需要N的时间成本。\n而二叉查找树就是一种能将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构，在平均情况下可以实现对数级别的插入和查询操作。\n1. 二叉查找树 定义：一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个键以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。\n2. 实现 由于二叉查找树不是一个完全二叉树，所以难以用数组很难去表示它。这就需要写一个类来表示二叉查找树上的一个结点。每一个节点需要含有一个键，一个值，一条指向左子结点的链接，一条指向右子结点的链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。结点计数器 给出了以该结点为根的子树的结点总数。\n1.查找元素\n根据二叉查找树的定义和性质，我们可以得出以下查找某一元素的算法：\n如果树是空的，则查找未命中； 如果被查找的键和根结点的键相等，查找命中； 如果未命中我们就在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。 如果最后没有找到该元素，则返回null；\n2.插入元素\n插入元素算法的实现逻辑和查找很相似：\n如果树是空的，就返回一个含有该键值对的新结点； 如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，在相等时更新结点的value值，否则在右子树中插入该键，并返回结点引用。 更新结点计数器\n3.rank排名\nrank 从1开始排序, 查找元素按键值排序的排名，根据二叉查找树的性质，算法思路如下：\n如果给定的键和根结点的键相等，我们返回左子树中的结点总数 t； 如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）； 如果给定的键大于根结点，我们会返回 t+1（根结点）加上它在右子树中的排名（递归计算）。\n二叉查找树的完整实现如下，上述 1.查找元素， 2.插入元素， 3.rank排名 分别对应方法：get(), put(), rank()。\nJava\npublic class BinarySearchTree { private Node root; //根节点 /** * 节点静态内部类 */ private static class Node { private int key; //节点键 private String value; //节点值 private Node left, right; //指向左右子树的连接 private int N; //以该节点为根的子树的节点数 Node(int key, String value, int N) { this.key = key; this.value = value; this.N = N; } } //根据键值获取节点的值，节点不存在返回NUll public String get(int key) { Node node = root; while (node != null){ if (key \u0026gt; node.key) node = node.right; else if (key \u0026lt; node.key) node = node.left; else return node.value; } return null; } //向二叉查找树插入一个节点，若节点存在则更新value public void put(int key, String value) { root = put(root, key, value); } private Node put(Node node, int key, String value) { if (node == null) return new Node(key, value, 1); if (key \u0026gt; node.key) node.right = put(node.right, key, value); else if (key \u0026lt; node.key) node.left = put(node.left, key, value); else node.value = value; node.N = size(node.left) + size(node.right) + 1; return node; } /** * rank 从1开始排序, 查找元素的排名 */ public int rank(int key){ return rank(root, key); } private int rank(Node node, int key){ if (node == null) return 0; if (key \u0026gt; node.key) return 1 + size(node.left) + rank(node.right, key); else if (key \u0026lt; node.key) return rank(node.left, key); else return size(node.left) + 1; } /** * 中序遍历打印所有节点 */ public void inorderPrint(){ inorderPrint(root); } private void inorderPrint(Node node){ if (node == null) return; inorderPrint(node.left); System.out.println(node.key); inorderPrint(node.right); } //查看最右侧路径上的节点值 public void printRight(){ Node node = root; while (node != null){ System.out.println(node.value); node = node.right; } } // 获取当前树的节点数 public int size() { return size(root); } private int size(Node node){ if (node == null) return 0; else return node.N; } }  其中静态内部类 Node 的一个对象代表一个二叉查找树的结点，中序遍历 inorderPrint()可以按结点键值的顺序来打印结点信息。\n3. 分析 使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 N 个结点的树是完全平衡的，每条空链接和根结点的距离都为～ lgN。在最坏的情况下，按键的顺序插入，搜索路径上可能有 N个结点。但在一般情况下树的形状和最好情况更接近。\n二叉查找树和快速排序几乎就是“双胞胎”。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），而这对于所有的子树同样适用，这和快速排序中对子数组的递归排序完全对应。这使我们能够分析得到二叉查找树的一些性质。在由 N 个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为∼ 2lnN（约 1.39lgN），在二叉查找树中查找随机键的成本比二分查找高约 39%。但是因为插入一个新键的成本是对数级别的，说明这些额外的成本是值得的。\n下表是基于有序数组实现二分查找，和基于二叉查找树实现查找和插入元素效率的对比。\n   算法(数据结构) 查找(最坏) 插入(最坏) 查找(平均) 插入(平均)     二分查找(有序数组) logN N logN N/2   二叉树查找(二叉查找树) N N 1.39logN 1.39logN    优缺点 1.优点：能够将链表插入的灵活性和有序数组查找的高效性结合起来，在平均情况下可实现对树中元素，在对数级别时间复杂度的插入，查找操作。\n2.缺点：不稳定，二叉查找树查找的性能根据树的形态确定，而插入元素的循序又决定的其形态，若是插入元素有序那么二叉查找树就会退化为链表。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/sorting/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/",
	"title": "2. Quick-Sort",
	"tags": [],
	"description": "",
	"content": " 快速排序 快速排序算法可能是应用最为广泛的算法，它的实现较为简单而且排序效率比大多数算法都要高。仅需要一个辅助栈就可以实现在原数组上原地排序。但是快速排序算法稳定性不高，如果使用不当经常可能使算法的性能降低至平方级别。如何正确使用和优化快速排序是使用它之前必须研究的问题。\n1. 基本实现 快速排序算法和并归的共性就是它们都是一种分治排序算法，而且在某种意义上，两种算法是互补的。并归是将待排序数组平分（递归的）两个子数组，将两个子数组排序后将结果并归起来就得到了一个有序数组。而快速排序是选取一个切分元素，将数组切分（递归的）为两个子数组，然后将两个子数组分别排序，子数组排序完成整个数组也就排好序了。这一区别在代码中的体现就是并归排序的递归调用发生在处理整个数组之前；在快速排序中，递归调用发生在处理整个数组之后。快速排序基本实现如下。\nJava\npublic class Quick { public static void sort(int[] a){ sort(a, 0, a.length - 1); } private static void sort(int[] a, int lo, int hi){ if(hi \u0026lt;= lo)return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } //切分操作 private static int partition(int[] a, int lo, int hi){ //左右扫描指针 int i = lo, j = hi+1; //切分元素 int V = a[lo]; while (true){ //扫描左右元素，出现左元素比V大或右元素比V小，则交换两元素位置。 while (a[++i] \u0026lt; V) if (i == hi) break; while (a[--j] \u0026gt; V) if (j == lo) break; if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); return j; } //交换元素位置 private static void exch(int[] a, int i, int j){ int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } }  此算法实现的关键在于切分如何实现，在上述代码中切分操作的实现思路为：\n 首先选取数组第一个元素为切分元素。\n 从左到右，从右到左的扫描数组，出现左元素比V大或右元素比V小，则交换两元素位置。\n 直到整个数组被扫描一遍后，切分完成。此时切分元素左的边元素都小于等于它，切分元素右边的元素都大于等于它，最后返回切分元素所在位置的索引。\n  2. 性能特点 快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点。归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。\n快速排序另一个速度优势在于它的比较次数很少。排序效率最终还是依赖切分数组的效果， 而 这依赖于切分元素的值。这就是让快速排序算法不稳定的因素。快速排序的最好情况是每次都正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的 CN=2CN/2+N 公式。 在前面属于分治递归的并归排序的算法时间复杂度证明得到此公式的解为：CN~NlgN。但是在使用是不可能每次都能有这样的好运气，所以我们需要在数学上证明一下其平均的时间复杂度，以便于更好的了解使用它。\n命题 K。将长度为 N 的无重复数组排序，快速排序平均需要 ~2NlnN 次比较（以及 1/6 的交换）。 证明。令 CN 为将 N 个不同元素排序平均所需的比较次数。显然 C0=C1=0，对于 N\u0026gt;1，由递归 程序可以得到以下归纳关系： CN=N+1+(C0+C1+...+CN-2+CN-1)/N+(CN-1+CN-2+...+C0)/N 第一项是切分的成本（总是 N+1），第二项是将左子数组（长度可能是 0 到 N-1）排序的平均成本， 第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以N并整理各项得到： NCN=N(N+1)+2(C0+C1+...+CN-2+CN-1) 将该等式减去 N-1 时的相同等式可得： NCN-(N-1)CN-1=2N+2CN-1 整理等式并将两边除以 N(N+1) 可得： CN/(N+1)=CN-1/N+2/(N+1) 归纳法推导可得： CN~2(N+1)(1/3+1/4+...+1/(N+1)) 括 号 内 的 量 是 曲 线 2/x 下 从 3 到 N 的 离 散 近 似 面 积 加 一， 积 分 得 到 CN~2NlnN。 注 意 到 2NlnN ≈ 1.39NlgN，也就是说平均比较次数只比最好情况多 39%。 要得到命题中的交换次数需要一个类似（但更加复杂的）分析。  总的来说，可以肯定的是对于大小为 N 的数组,上述的快速排序算法的运行时间在 1.39NlgN 的某个常数因子的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多39%），因为它移动数据的次数更少。\n3. 算法改进 实际应用中经常会出现含有大量重复元素的数组，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级的性能提高到线性级别。\nJava\npublic class Quick3way { public static void sort(int[] a){ sort(a, 0, a.length - 1); } private static void sort(int[] a, int lo, int hi){ if (hi \u0026lt;= lo) return; int lt = lo, i = lo+1, gt = hi; int v = a[lo]; while (i \u0026lt;= gt) { if (a[i] \u0026lt; v) exch(a, lt++, i++); else if (a[i] \u0026gt; v) exch(a, i, gt--); else i++; } // 现在 a[lo..lt-1] \u0026lt; v = a[lt..gt] \u0026lt; a[gt+1..hi]成立 sort(a, lo, lt - 1); sort(a, gt + 1, hi); } //交换元素位置 private static void exch(int[] a, int i, int j){ int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } }  Dijkstra 的解法如上所示。它从左到右遍历数组一次，维护一个指针 lt 使得 a[lo..lt-1] 中的元素都小于 v，一个指针 gt 使得 a[gt+1..hi] 中的元素都大于 v，一个指针 i 使得 a[lt..i-1] 中的元素都等于 v， a[i..gt] 中的元素都还未确定。直到while循环完成后，就达到了a[lo..lt-1] \u0026lt; v = a[lt..gt] \u0026lt; a[gt+1..hi]成立的效果。对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/searching/",
	"title": "Searching",
	"tags": [],
	"description": "",
	"content": " Search Notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/mybatis%E6%98%A0%E5%B0%84%E5%99%A81/",
	"title": "2. Mybatis映射器1",
	"tags": [],
	"description": "",
	"content": " 一. Mybatis配置文件概述 Mybatis核心配置文件 mybatis-config.xml 配置了很多影响Mybatis行为的信息，在一个项目内此文件不会轻易改动，而且在与 Spring 框架整合后 Mybatis 核心配置文件信息将配置到 Spring 的配置文件中。我们平时应用只需基础的了解一下常用的配置。\nmybatis-config.xml 常用配置模板代码如下：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;propertises/\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 设置 --\u0026gt; \u0026lt;setting name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases /\u0026gt; \u0026lt;!-- 类型别名 --\u0026gt; \u0026lt;typeHandlers\u0026gt;\u0026lt;/typeHandlers\u0026gt; \u0026lt;!-- 类型处理器 --\u0026gt; \u0026lt;objectFactory type=\u0026quot;\u0026quot;\u0026gt; \u0026lt;!-- 对象工厂 --\u0026gt; \u0026lt;property name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;/objectFactory\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;!-- 插件 --\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;!-- 事务管理器 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;databaseIdProvider type=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;!--数据库厂商标识 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- 映射器 --\u0026gt; \u0026lt;mapper resource=\u0026quot;org/mybatis/example/BlogMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  二. Mybatis映射器四大元素 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。映射器 xml 文件的四大元素（标签）分别对应 Sql 语句的 select, insert, delete, update\n1.\u0026lt;select\u0026gt;元素 查询语句是 Mybatis 中最常用的元素之一，大多数应用的查询语句比插入，删除和更新更频繁，更复杂。\u0026lt;select\u0026gt;元素配置的实例代码如下。\n\u0026lt;select id=\u0026quot;selectOneBySnum\u0026quot; resultType=\u0026quot;bean.Student\u0026quot; parameterType=\u0026quot;Integer\u0026quot;\u0026gt; select * from student where snum=#{snum} \u0026lt;/select\u0026gt;  在上述代码中\u0026lt;select\u0026gt;元素配置了3个属性，分别是id，resultType和parameterType，id 属性指定 \u0026lt;select\u0026gt; 元素的唯一表示符，resultType 指定元素返回 bean.Student 类型的对象。parameterType 指定元素接受的参数类型为 Integer 类型。\n\u0026lt;select\u0026gt;元素除了上述几个属性之外，还有一些其他的属性，如下表所示。\n   属性 描述     id 在命名空间中唯一的标识符，可以被用来引用这条语句。   parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）   resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。   resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。   flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。   useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。   timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。   fetchSize 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。   statementType STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。   resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。   databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。   resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。   resultSets 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。    2.,和元素 ,和 三个元素分别用于映射插入，更新和删除语句，这三标签元素的实现类似，它们执行完成后都会返回一个整数，表示其影响了数据库的记录行数。它们各自的属性如下图所示。\n\u0026lt;insert id=\u0026quot;insertAuthor\u0026quot; parameterType=\u0026quot;domain.blog.Author\u0026quot; flushCache=\u0026quot;true\u0026quot; statementType=\u0026quot;PREPARED\u0026quot; keyProperty=\u0026quot;\u0026quot; keyColumn=\u0026quot;\u0026quot; useGeneratedKeys=\u0026quot;\u0026quot; timeout=\u0026quot;20\u0026quot;\u0026gt; \u0026lt;update id=\u0026quot;updateAuthor\u0026quot; parameterType=\u0026quot;domain.blog.Author\u0026quot; flushCache=\u0026quot;true\u0026quot; statementType=\u0026quot;PREPARED\u0026quot; timeout=\u0026quot;20\u0026quot;\u0026gt; \u0026lt;delete id=\u0026quot;deleteAuthor\u0026quot; parameterType=\u0026quot;domain.blog.Author\u0026quot; flushCache=\u0026quot;true\u0026quot; statementType=\u0026quot;PREPARED\u0026quot; timeout=\u0026quot;20\u0026quot;\u0026gt;  三标签元素属性的解释如下表。\n   属性 描述     id 命名空间中的唯一标识符，可被用来代表这条语句。   parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器推断出具体传入语句的参数，默认值为未设置（unset）。   flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。   timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）   statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED   useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。   keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。   keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。   databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。    ,和的简单使用。\n\n \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;bean.Student\u0026quot; keyProperty=\u0026quot;snum\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; \u0026gt; insert into student4044(snum,name,classnum,javaee,android,s_sql,total) VALUES(#{snum},#{name},#{classnum},#{javaee},#{android},#{sql},#{total}) \u0026lt;/insert\u0026gt;  \n \u0026lt;update id=\u0026quot;updateStudent\u0026quot;\u0026gt; update student4044 set name=#{name},classnum=#{classnum},javaee=#{javaee},android=#{android},s_sql=#{sql},total=#{total} where snum=#{snum} \u0026lt;/update\u0026gt;  \n \u0026lt;delete id=\u0026quot;deleteStudent\u0026quot; parameterType=\u0026quot;String\u0026quot;\u0026gt; delete from student4044 where snum = #{snum}; \u0026lt;/delete\u0026gt;  "
},
{
	"uri": "https://compass-ak.gitee.io/android/activity/acticity%E7%9A%84%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD/",
	"title": "2. Acticity的创建,启动和关闭",
	"tags": [],
	"description": "",
	"content": " 现在的大多数Android IDE 都可以直接创建 Activity “类型”的 java 类，以及完成一系列的操作。我们做 Android 开发肯定需要知道其中的具体步骤细节。\n1. Activity的创建 创建一个 Activity 必须继承Activity的子类或现有的子类，一个常规的Activity的创建包含以下几个步骤：\n 创建一个Java类。\n 继承Activity的子类：这个子类可以是我们自己继承Activity写的也可以是现有的Activity的子类。我们继承的是 AppCompatActivity现有子类。\n 在AndroidManifest.xml 清单文件中声明注册Activity：系统不会识别和运行任何未进行声明的 Activity。在声明注册一个Activity时我们需要用到\u0026lt;activity\u0026gt;标签，\u0026lt;activity\u0026gt;的常用属性如下:\n     属性 说明     android:banner=\u0026ldquo;drawable resource\u0026rdquo; 为Acticity关联项提供扩展图形化横幅的可绘制资源   android:clearTaskOnLaunch=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 为true时用户再次启动任务，会清除其他Activity直接启动应用根Activity,为false不清除,默认为false   android:colorMode=[ \u0026ldquo;hdr\u0026rdquo; | \u0026ldquo;wideColorGamut\u0026rdquo;] 请求在兼容设备上以广色域模式显示 Activity   android:directBootAware=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] Activity 是否支持直接启动，即其是否可以在用户解锁设备之前运行   android:enabled=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 系统是否可实例化 Activity   android:excludeFromRecents=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 是否应从最近使用的应用列表（即概览屏幕）中排除该 Activity 启动的任务   android:exported=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 表示此元素设置 Activity 是否可由其他应用的组件启动   android:finishOnTaskLaunch=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 每当用户再次启动 Activity 的任务（在主屏幕上选择任务）时，是否应关闭（完成）现有的 Activity 实例   android:hardwareAccelerated=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 是否应为此 Activity 启用硬件加速渲染 —“true”表示应启用，“false”表示不应启用。默认值为“false”   android:icon=\u0026ldquo;drawable resource\u0026rdquo; 指定 Activity 的图标   android:label=\u0026ldquo;string resource\u0026rdquo; 一种可由用户读取的 Activity 标签。在必须向用户呈现 Activity 时，屏幕上会显示此标签。此标签通常与 Activity 图标一并显示   android:launchMode=[\u0026ldquo;standard\u0026rdquo; | \u0026ldquo;singleTop\u0026rdquo; |\u0026ldquo;singleTask\u0026rdquo; | \u0026ldquo;singleInstance\u0026rdquo;] 有关应如何启动 Activity 的指令   android:name=\u0026ldquo;string\u0026rdquo; 实现 Activity 的类的名称，是 Activity 的子类。此属性值应为完全限定类名称   android:noHistory=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 当用户离开 Activity 且屏幕上不再显示该 Activity 时，是否应从 Activity 堆栈中将其移除并完成（调用其 finish() 方法）默认为 false   android:parentActivityName=\u0026ldquo;string\u0026rdquo; Activity 逻辑父项的类名称。   android:resizeableActivity=[\u0026ldquo;true\u0026rdquo; | \u0026ldquo;false\u0026rdquo;] 指定应用是否支持多窗口显示。   android:screenOrientation=[\u0026ldquo;unspecified\u0026rdquo; | \u0026ldquo;behind\u0026rdquo; |\u0026ldquo;landscape\u0026rdquo; | \u0026ldquo;portrait\u0026rdquo; |\u0026ldquo;reverseLandscape\u0026rdquo; | \u0026ldquo;reversePortrait\u0026rdquo; |\u0026ldquo;sensorLandscape\u0026rdquo; | \u0026ldquo;sensorPortrait\u0026rdquo; |\u0026ldquo;userLandscape\u0026rdquo; | \u0026ldquo;userPortrait\u0026rdquo; |\u0026ldquo;sensor\u0026rdquo; | \u0026ldquo;fullSensor\u0026rdquo; | \u0026ldquo;nosensor\u0026rdquo; |\u0026ldquo;user\u0026rdquo; | \u0026ldquo;fullUser\u0026rdquo; | \u0026ldquo;locked\u0026rdquo;] Activity 在设备上的显示方向。   android:theme=\u0026ldquo;resource or theme\u0026rdquo; 对定义 Activity 总体主题的样式资源的引用   android:windowSoftInputMode=[\u0026ldquo;stateUnspecified\u0026rdquo;, \u0026ldquo;stateUnchanged\u0026rdquo;, \u0026ldquo;stateHidden\u0026rdquo;,\u0026ldquo;stateAlwaysHidden\u0026rdquo;, \u0026ldquo;stateVisible\u0026rdquo;, \u0026ldquo;stateAlwaysVisible\u0026rdquo;, \u0026ldquo;adjustUnspecified\u0026rdquo;,\u0026ldquo;adjustResize\u0026rdquo;, \u0026ldquo;adjustPan\u0026rdquo;] Activity 的主窗口与包含屏幕软键盘的窗口之间的交互方式    \u0026lt;activity\u0026gt; 标签应为\u0026lt;application\u0026gt;标签的子标签，下面是一个AndroidManifest.xml 下\u0026lt;activity\u0026gt;的声明示例：\n\u0026lt;application android:allowBackup=\u0026quot;true\u0026quot; android:icon=\u0026quot;@mipmap/ic_launcher\u0026quot; android:label=\u0026quot;@string/app_name\u0026quot; android:roundIcon=\u0026quot;@mipmap/ic_launcher_round\u0026quot; android:supportsRtl=\u0026quot;true\u0026quot; android:theme=\u0026quot;@style/AppTheme\u0026quot;\u0026gt; \u0026lt;activity android:name=\u0026quot;.ExampleActivity\u0026quot; android:icon=\u0026quot;@drawable/icon\u0026quot; android:label=\u0026quot;Example\u0026quot;\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026quot;.MainActivity\u0026quot;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt;  我们在前两步定义了ExampleActivity，在声明是用android:name属性指定类名（推荐使用完全限定类名，可以如上简写）。\u0026lt;activity\u0026gt;标签下可以有\u0026lt;intent-filter\u0026gt;意图过滤标签来过滤 Intent ，可以根据自己Activity的功能来为其设置 Intent 过滤器，以方便其响应应用内外的工作任务。 \u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt; 指定MainActivity过滤 启动应用时发出的 Action动作为android.intent.action.MAIN\u0026quot; 的意图，响应意图MainActivity就会启动。MainActivity就变成了应用的根Activity。一个应用只能有一个根Activity，也就是说一个应用只有一个Activity能使用此过滤器。\n\r 创建与Activity对应的布局文件(activity_example.xml)：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.ExampleActivity\u0026quot;\u0026gt; \u0026lt;TextView android:id=\u0026quot;@+id/textView\u0026quot; android:layout_width=\u0026quot;wrap_content\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:text=\u0026quot;@string/hello_activity\u0026quot; android:textSize=\u0026quot;24sp\u0026quot; app:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot; app:layout_constraintEnd_toEndOf=\u0026quot;parent\u0026quot; app:layout_constraintStart_toStartOf=\u0026quot;parent\u0026quot; app:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot; app:layout_constraintVertical_bias=\u0026quot;0.398\u0026quot; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   至此一个Activity就算是创建完成了。\n2. Activity的启动和关闭 2.1 Activity的启动 启动一个 Activity 通常需要使用 startActivity() 或 startActivitys() 方法来实现，我们主要介绍 startActivity()。\n startActivity() 用来启动单个 Activity，其语法格式如下:\npublic void startActivity(Intent intent)  该方法接受一个 Intent对象参数用于指定跳转到的 Activity，具体步骤如下：\nIntent intent = new Intent(this, ExampleActivity.class); startActivity(intent);  表示由当前的Activity跳转到名为ExampleActivity的Activity\n startActivitys()用来启动多个Activity ，其语法格式如下：\npublic void startActivitys(Intent [] intents)  该方法接受一个 Intent[] 对象数组参数用于指定跳转到的 Activity，由于屏幕最前端只能显示一个Activity ,最后启动的 Activity 在屏幕的最上方获得用户焦点。用户返回时会依次显示之前的 Activity 。其调用方法与 startActivity() 类似。\n  2.2 Activity启动的例子 我们在新建了一个 ExampleActivity, 在 MainActivity 添加一个Button控件，添加事件监听器。在点击时跳转到ExampleActivity。Button 事件监听器的 onClick() 方法内容如下：\n@Override public void onClick(View view) { Intent intent = new Intent(MainActivity.this, ExampleActivity.class); startActivity(intent); }     MainActivity ExampleActivity          点击 MainActivity上的 Button 系统就会新建一个 ExampleActivity 并跳转到它。\n2. Activity的启动和关闭 想要结束销毁一个Activity，可以通过调用 Activity 的 finish() 方法来结束该 Activity。我们还可以通过调用 finishActivity() 结束您之前启动的另一个 Activity。\n在大多数情况下，我们尽量不要调用这些方法显示的结束一个Activity，就像我们上一篇文章讲到 Activity 的生命周期。Android 系统会自动管理Activity的生命周期，因此您无需结束自己的 Activity。 调用这些方法可能对预期的用户体验产生不良影响，因此只应在您确实不想让用户返回此 Activity 实例时使用。\n\r"
},
{
	"uri": "https://compass-ak.gitee.io/android/",
	"title": "Android",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Android Notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/",
	"title": "Mybatis",
	"tags": [],
	"description": "",
	"content": " Chapter 3.2 Mybatis Notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/tomcat%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/",
	"title": "2. Tomcat的安装配置",
	"tags": [],
	"description": "",
	"content": "# []()Tomcat安装与配置\n上一小节理解了web服务器的工作原理，继续下面的学习我们需要安装一个 web服务器。我们选用的是Tomcat web服务器，下面先开始安装Tomcat：\n！提示：安装运行 Tomcat 需要有 Java 环境\n1.下载 Tomcat\n官网：https://tomcat.apache.org/\n如下图所示，选择相应版本!\n我选择的是 Tomcat8，点击链接后，选择Core目录下的版本，如下图。\n其中的两个版本：32-bit/64-bit windows zip(pgp,sha512)，不需要安装。可根据机器选择32位还是64位，32-bit/64-bit Windows Service Installer (pgp, sha512) 是需要安装的版本，我选择的是不需要安装的版本。下载完成解压后文件目录如下。\n运行 bin 里面的 startup.bat 文件，运行成功且窗口未关闭就配置成功了一半。如下图所示。\n接下来在浏览器地址栏输入 http://localhost:8080/ ,Tomcat 的默认端口是8080端口，如果浏览器出现以下页面就算是配置成功了。\n最后更新一个问题，应该有许多人配置好后，控制台输出的中文可能会乱码，需要更改注册表数据，在 HKEY_CURRENT_USER\\Console\\Tomcat 注册表目录下更改 Tomcat CodePage 项（没有创建一个）的值更改为10进制的65001，之后重启 Tomcat 就解决了。\n~~\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/graphs/mst/",
	"title": "3. Minimum-Spanning-Tree",
	"tags": [],
	"description": "",
	"content": " 最小生成树 讨论最小生成树要基于一种叫 加权图 的图模型。加权图的 加权 的含义是为图的每一条边关联一个权值或是成本。这种图相比于无向图可以更细致的描述问题。在一幅航空图中，边表示航线，权值则可以表示距离或是费用。在一幅电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条线路所需的时间。我们可以根据这些信息设计算法计算出最合适的航线，设计一个线路规划最良好的线路。\n而 最小生成树(Minimum-Spanning-Tree) 和解决上述一类问题有着密切的联系，图的 生成树 是它的一颗含有其所有顶点的无环连通子图。 最小生成树 是所有边的权值之和最小的那颗生成树。 值得一提的是边的权值为了适应更多的问题是允许为负数的。\n1. 加权无向图数据类型 表示加权无向图有多种方法，可以使用前面几篇文章中无向图的方法，只需要在结点中增加一个权值属性。 但是由于加权无向图中对边的操作非常频繁，所以会做一些小改动，邻接表存放的不是结点而是一个个边（Edge）对象。根据加权无向图中边的定义，描述它需要三个属性：一个顶点，另一个顶点，权重。以及实现重写一些必要的方法。具体如下：\npublic class Edge { private final int v; // 顶点之一 private final int w; // 另一个顶点 private final double weight; // 边的权重 public Edge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } public double weight() { return weight; } public int either() { return v; } public int other(int vertex) { if (vertex == v) return w; else if (vertex == w) return v; else throw new RuntimeException(\u0026quot;Inconsistent edge\u0026quot;); } public String toString() { return String.format(\u0026quot;%d-%d %.2f\u0026quot;, v, w, weight); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof Edge)) return false; Edge e = (Edge)obj; return this.v == e.v \u0026amp;\u0026amp; this.weight == e.weight \u0026amp;\u0026amp; this.w == e.w; } }  该数据结构提供了 either() 和 other() 两个方法。在已知一个顶点 v 时，用例可以使用 other(v)来得到边的另一个顶点。当两个顶点都是未知的时候，用例可以使用惯用代码 v=e.either(), w=e.other(v); 来访问一个 Edge 对象 e 的两个顶点。 重写了 equals() 方法方便边的比较，排序。\n加权无向图 数据类型与无向图数据类型类似，不同的地方在于将邻接表元素由结点变为了边对象，具体实现如下：\npublic class EdgeWeightedGraph { private final int V; // 顶点总数 private int E; // 边的总数 private List\u0026lt;ArrayList\u0026lt;Edge\u0026gt;\u0026gt; adj; // 邻接表 public EdgeWeightedGraph(int V) { this.V = V; this.E = 0; adj = new ArrayList\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; V; v++) adj.add(new ArrayList\u0026lt;\u0026gt;()); } public EdgeWeightedGraph(BufferedReader reader) throws IOException { this(Integer.parseInt(reader.readLine())); // 读取 V int E = Integer.parseInt(reader.readLine()); // 读取 E for (int i = 0; i \u0026lt; E; i ++){ String str = reader.readLine(); String[] edge= str.split(\u0026quot; \u0026quot;); int v = Integer.parseInt(edge[0]); int w = Integer.parseInt(edge[1]); double weight = Double.parseDouble(edge[2]); addEdge(new Edge(v, w, weight)); // 添加边 } } public int V() { return V; } public int E() { return E; } public void addEdge(Edge e) { int v = e.either(), w = e.other(v); adj.get(v).add(e); adj.get(w).add(e); E++; } public List\u0026lt;Edge\u0026gt; adj(int v) { return adj.get(v); } public List\u0026lt;Edge\u0026gt; edges() { List\u0026lt;Edge\u0026gt; es = new ArrayList\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; V; v++) for (Edge e : adj.get(v)) if (e.other(v) \u0026gt; v) es.add(e); return es; } }  EdgeWeightedGraph 与 Graph 有很多相似的地方，第二个构造函数中增加了一行代码获取边的权重。增加了一个 edges() 方法可以获取加权图所有的边。\n2. 原理 由于最小生成树是一棵树，树的性质最小生成树也是具备的。其中对于证明最小生成树高度相关的两条性质如下：\n 用一条边连接树的任意两个顶点都会产生一个新环。\n 一颗树删去任意一条边将会得到两颗独立的树。\n  这两条性质是证明最小生成树的另一条基本性质的基础。\n2.1 切分定理\n图的一种切分是将图的所有顶点分为两个非空且不重叠的两个集合。横切边是一条连接两个属于不同集合的顶点的边。我们称之为切分定理的这条性质将会把加权图中的所有顶点分为两个集合、检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树。\n切分定理： 在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。 证明 ： 今 e 为权重最小的横切边， T 为图的最小生成树。我们采用反证法：假设 T 不包含 e。那么如果将 e 加入 T，得到的图必然含有一条经过 e 的环，且这个环至少含有另一条横切边——设为 f， f 的权重必然大于 e（因为 e 的权重是最小的且图中所有边的权重均不同）。那么我们删掉 f 而保留 e 就可以得到一棵权重更小的生成树。这和我们的假设 T 矛盾。  在所有边权重不同的情况下，加权连通图的最小生成树是唯一的。\n切分定理是解决最小生成树问题的所有算法的基础。 更确切的说，这些算法都是一种贪心算法的特殊情况：使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法相互之间的不同之处在于保存切分和判定权重最小的横切边的方式，但它们都是以下性质的特殊情况。\n3. Prim 算法 prim 算法是一种经典的计算加权连通图最小生成树的算法。基于切分定理，它的每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的加入树中。\n其中有一个重要的问题是怎么高效的寻找到横切边集合中权重最小的边，很显然这活还得优先队列来干最容易。所以每次横切时，将横切边集合加入到一个优先队列（按边的权重排序），直接取堆顶的元素就是权重最小边。\n3.1 延迟实现\n在 prim 算法的延迟实现 LazyPrimMST 中，使用一个由顶点索引的布尔数组 marked[]，如果顶点 v 在树中，那么 marked[v] 的值为 true。 使用一个普通队列 mst 存储最小生成树的边。使用了一个优先队列 PriorityQueue 存储每一次横切产生的横切边集合。构造生成优先队列时需要指明排序的依据：边的权重。在构造函数中传入 lamda 表达式指定。具体实现如下。\npublic class LazyPrimMST { private boolean[] marked; // 最小生成树的顶点 private Queue\u0026lt;Edge\u0026gt; mst; // 最小生成树的边 private PriorityQueue\u0026lt;Edge\u0026gt; pq; // 横切边（包括失效的边） public LazyPrimMST(EdgeWeightedGraph G) { pq = new PriorityQueue\u0026lt;\u0026gt;((o1, o2) -\u0026gt; { if ((o1.weight() - o2.weight()) \u0026gt; 0) return 1; else if ((o1.weight() - o2.weight()) == 0) return 0; else return -1; }); marked = new boolean[G.V()]; mst = new ArrayDeque\u0026lt;\u0026gt;(); // 假设G是连通的 visit(G, 0); while (!pq.isEmpty()) { // 从pq中得到权重最小的边 Edge e = pq.poll(); int v = e.either(), w = e.other(v); // 跳过失效的边 if (marked[v] \u0026amp;\u0026amp; marked[w]) continue; // 将边添加到树中 mst.add(e); // 将顶点（v或w）添加到树中 if (!marked[v]) visit(G, v); if (!marked[w]) visit(G, w); } } private void visit(EdgeWeightedGraph G, int v) { // 标记顶点v并将所有连接v和未被标记顶点的边加入pq marked[v] = true; for (Edge e : G.adj(v)) if (!marked[e.other(v)]) pq.add(e); } public Iterable\u0026lt;Edge\u0026gt; edges() { return mst; } public double weight(){ double sum = 0; for (Edge e : mst){ sum += e.weight(); } return sum; } }  运行时间\n命题 : Prim 算法的延时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间与 E 成正比，所需的时间与 ElogE 成正比（最坏情况）。 证明 : 算法的瓶颈在于优先队列的 insert() 和 delMin() 方法中比较边的权重的次数。优先 队列中最多可能有 E 条边，这就是空间需求的上限。在最坏情况下，一次插入的成本为～ lgE， 删除最小元素的成本为～ 2lgE（请见第 2 章的命题 Q）。因为最多只能插入 E 条边，删除 E 次最小元素，时间上限显而易见。  3.2 即时实现\n3.1 中延迟实现 LazyPrimMST 使用了一条优先队列来保存所有的横切边，不足的地方就是会在优先队列中保留失效的边。想要改进 LazyPrimMST，可以尝试从优先队列中删除失效的边。 我们感兴趣的只是连接树顶点和非树顶点中权重最小的边。我们不需要在优先队列中保存所有从 w 到树顶点的边——而只需要保存其中权重最小的那条。遇到连接 w 与树权重更小的边就及时更新替换就行。\n在 PrimMST 的实现中，使用了一个静态内部类 Node 代替 LazyPrimMST 中的Edge 边存储在优先队列中。Node 存储了顶点以及其到树最佳边的权值，这样优先队列存储的对象数量就从（顶点数 + 无效边数）降到了（顶点数）在大规模的问题中这可能是非常巨大的花销。\n由于顶点到最小生成树的最优边是在动态变化的，所以无法使用一个队列来存储顶点连接最小生成树的边。在 PrimMST 中使用 edgeTo[v] 保存“当前情况下”顶点到树的最小权重的边，可以支持不断的更新。distTo[v] 为 edgeTo[v] 这条边的权重。\n具体实现如下\npublic class PrimMST { private Edge[] edgeTo; // 距离树最近的边 private double[] distTo; // distTo[w]=edgeTo[w].weight() private boolean[] marked; // 如果v在树中则为true private PriorityQueue\u0026lt;Node\u0026gt; pq; // 有效的横切边 private static class Node{ int v; // 顶点 Double weight; // 连接顶点 v 和树的最佳边的权重 Node(int v, Double weight){ this.v = v; this.weight = weight; } @Override public boolean equals(Object obj){ if (this == obj) return true; if (!(obj instanceof Node)) return false; Node node = (Node)obj; return this.v == node.v \u0026amp;\u0026amp; this.weight.equals(node.weight); } } public PrimMST(EdgeWeightedGraph g){ edgeTo = new Edge[g.V()]; distTo = new double[g.V()]; marked = new boolean[g.V()]; for (int v = 0; v \u0026lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; pq = new PriorityQueue\u0026lt;\u0026gt;(Comparator.comparing(o -\u0026gt; o.weight)); distTo[0] = 0.0; // 用顶点0和权重0初始化pq pq.add(new Node(0, 0.0)); while (!pq.isEmpty()) // 将最近的顶点添加到树中 visit(g, pq.poll().v); } private void visit(EdgeWeightedGraph G, int v) { // 将顶点v添加到树中，更新数据 marked[v] = true; for (Edge e : G.adj(v)) { int w = e.other(v); // v-w失效 if (marked[w]) continue; if (e.weight() \u0026lt; distTo[w]) { // 连接w和树的最佳边Edge变为e edgeTo[w] = e; distTo[w] = e.weight(); Node node = new Node(w, distTo[w]); for (Object obj : pq.toArray()) { if (((Node) obj).v == node.v) { pq.remove(obj); break; } } pq.add(node); } } } public List\u0026lt;Edge\u0026gt; edges() { return new ArrayList\u0026lt;\u0026gt;(Arrays.asList(edgeTo).subList(1, edgeTo.length)); } public double weight(){ List\u0026lt;Edge\u0026gt; mst = edges(); double sum = 1; for (Edge e : mst){ sum += e.weight(); } return sum-1; } }  PrimMST 会从优先队列中取出一个顶点 v 并检查它的邻接链表中的每条边v-w。如果 w 已经被标记过，那么这条边就已经失效了；如果 w 不在优先队列中或者 v-w 的权重小于目前已知的最小值 edgeTo[w]，代码会更新数组，将 v-w 作为将 w 和树连接的最佳选择。\n运行时间\n命题 : Prim 算法的即时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间和 V 成正比，所需的时间和 ElogV 成正比（最坏情况）。 证明。因为优先队列中的顶点数最多为 V，且使用了三条由顶点索引的数组，所以所需空间的 上限和 V 成正比。算法会进行 V 次插入操作， V 次删除最小元素的操作和（在最坏情况下） E 次改变优先级的操作。已知在基于堆实现的索引优先队列中所有这些操作的增长数量级为 logV 所以将所有这些加起来可知算法所需时间和 ElogV 成正比  Kruskal 算法 Kruskal 算法与 prim 算法不同的是：prim 算法以顶点为单位处理图，而Kruskal 算法则是以边为单位处理图。\nKruskal 算法的主要思想是按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有 V-1条边为止。具体实现如下。\npublic class KruskalMST { private Queue\u0026lt;Edge\u0026gt; mst; public KruskalMST(EdgeWeightedGraph g){ mst = new ArrayDeque\u0026lt;\u0026gt;(); PriorityQueue\u0026lt;Edge\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((o1, o2) -\u0026gt; { if ((o1.weight() - o2.weight()) \u0026gt; 0) return 1; else if ((o1.weight() - o2.weight()) == 0) return 0; else return -1; }); pq.addAll(g.edges()); UF uf = new UF(g.V()); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; g.V()-1){ Edge e = pq.poll(); int v = e.either(), w = e.other(v); if (uf.find(v) == uf.find(w)){ continue;} uf.union(v, w); mst.add(e); } } public Iterable\u0026lt;Edge\u0026gt; edges(){ return mst; } public double weight(){ double sum = 0; for (Edge e : mst){ sum += e.weight(); } return sum; } }  Kruskal 算法的实现使用了一条队列来保存最小生成树中的所有边、一条优先队列来保存还未被检查的边和一个 union-find 的数据结构来判断无效的边。最小生成树的所有边会按照权重的升序返回给用例。\n运行时间\n命题 : Kruskal 算法的计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间和 E 成正比，所需的时间和 ElogE 成正比（最坏情况）。 证明: 算法的实现在构造函数中使用所有边初始化优先队列，成本最多为 E 次比较。 优先队列构造完成后，其余的部分和 Prim 算法完全相同。优先队列中最多可能含有 E 条边， 即所需空间的上限。每次操作的成本最多为 2lgE 次比较，这就是时间上限的由来。 Kruskal 算 法最多还会进行 E 次 connected() 和 V 次 union() 操作，但这些成本相比 ElogE 的总时间的增长数量级可以忽略不计。  Kruskal 算法执行的时间在表达式上与 延时实现的 LazyPrimMST 相等，但是Kruskal 算法一般还是比 LazyPrimMST 算法要慢一些，因为在处理每条边时除了两种算法都要完成的优先队列操作之外，它还需要进行一次 connect() 操作。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/graphs/",
	"title": "Graphs",
	"tags": [],
	"description": "",
	"content": " Search Notes "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/searching/%E7%BA%A2%E9%BB%91%E6%A0%91/",
	"title": "3. Red-Black-BST",
	"tags": [],
	"description": "",
	"content": " 红黑二叉查找树 -图片资料来自 Algorithms, 4th Edition\n基于二叉查找树的查找和插入算法已经可以应用在许多的用例特定的应用程序上，但是在最坏的情况下，其结构退化为链表的性能急剧降低。这是让人无法容忍的。\n由于二叉查找树的查询性能依赖于树的形态，如果可以找到一种方法可以让二叉查找树无论如何构造，都可以处于一个平衡的状态。我们就可以在更多的情况下应用二叉查找树的高效查找和插入等操作。\n在理想情况下我们希望二叉查找树能在每次插入，删除等操作后都保持一个完美的平衡状态。在一颗含有N个结点的二叉查找树中，树高为lgN。这样就可以保证在lgN次比较内查询到元素，达到二分查找的性能。\n但是实际情况是，在动态的插入和删除等操作中保持二叉查找树的完美平衡的代价太高了，我们需要降低要求，让二叉查找树保持一个接近于完美平衡的状态。这就是红黑二叉查找树。\n1. 2-3查找树 学习红黑二叉查找树之前，我们需要先了解2-3查找树，它可以让我们更好的了解红黑二叉查找树保持树平衡的原理。\n在一般情况下，我们将一颗标准二叉查找树上的结点称为：2-结点（含有一个键和两条链接）。为了保持树的平衡性，在一颗2-3查找树中还含有：3-结点（含有两个键三条链接）,左链接指向的 2-3 树中的键都小于该结点，中链接指向的 2-3 树中的键都位于该结点的两个键之间，右链接指向的 2-3树中的键都大于该结点。下图所示就是一颗2-3查找树。\n2-3 树\n了解2-3查找树的基本结构后，我们进一步学习分析2-3查找树如何完成二叉查找树的各项功能，以及其保持树的完美平衡的方法。\n1.1 查找\n2-3查找树的查找算法与二叉查找树基本类似，只是2-3树会多一些判断，只要将二叉查找树的查找算法一般化我们就可以得到2-3查找树的算法。判断一个键是否在2-3查找树中的基本流程为：\n 将查找键与根结点中的键比较，如果它与其中任意一个是等，查找命中。\n 若未命中，根据比较结果确定查找键对应的区间，根据区间的链接找到子树继续递归的查找。\n 如果链接最后为空链接，则查询未命中。\n  1.2 向2-结点插入新键\n在二叉查找树中，进行一个插入操作首先会进行一次未命中查找。然后将新结点插入到树的底部，这样就有可能破坏树的平衡性。\n而在一颗2-3查找树中，如果查找未命中结束于一个2-结点。我们只需要将2-结点替换为3-结点。将需要插入的键保存在其中即可，如下图所示。\n向2-结点插入新键\n1.3 向3-结点插入新键\n向3-结点中插入新键就比向2-结点中插入新键要更复杂一些，因为3-结点已经含有了两个键没有插入空间了。但是为了将新键插入，我们可以键该键临时的存入该结点中,该结点就成为了一个4-结点（含有3个键4条链接）。由于4-结点是临时的，我们必须将它分解变换成2-结点或3-结点，一颗4-结点很容易转换成一颗由3个2-结点构成的2-3查找树。原4-结点中的中间结点成为此树的根节点。这颗树既是一个3个结点的二叉树，也是一颗完美平衡的2-3树。转换的过程揭示了一颗2-3树是如何 “生长” 的。具体如下图所示。\n向3-结点插入新键\n1.4 向一个父结点是2-结点的3-结点中插入新键\n假设一次插入的未命中查找操作结束于一个3-结点，且它的父结点是一颗2-结点。在这种情况下我们需要保持树的完美平衡的前提下，将新键插入。我们可以像在1.3节中描述的一样，将3-结点临时的转换为一个4-结点，但是此时我们不能直接将4-结点分解为2-结点，因为此操作会破坏2-3树的完美平衡。我们将4-结点的中键上移存入原来父结点中。其他两个键分解为2个2-结点，连接在父结点原中键两端的链接上。由于原来的父结点是2-结点有插入空间，可以直接将中键插入到此结点中。经过此操作2-3树任是完美平衡的，所有的空链接到根结点的距离仍然相等，具体过程如下图所示。\n向一个父结点是2-结点的3-结点中插入新键\n1.5 向一个父结点是3-结点的3-结点中插入新键\n假设一次插入的未命中查询操作结束于一个父结点为3-结点的3结点中。和1.4一样我们先构造一个临时的4-结点，然后将它的中键移动到父结点中。但是父结点也是一个3-结点，因此我们需要再次构建一个临时4-结点，然后进行相同的变换，分解结点并将中键移动到父结点中。如果路径上的结点除开根结点全部都是3-结点，我们就需要一直重复构建和分解临时的4-结点，将中键插入更高层的父结点中。直到最后达到根结点。具体过程如下图所示。\n向一个父结点是3-结点的3-结点中插入新键\n1.6 分解根结点\n如果从插入结点到到根节点全部都是3-结点，在经历数次变换后根结点最后会变换成一个临时的4-结点。此时我们就可以直接将4-结点直接分解为3个2-结点，它的中键变成新的根节点，左右两个键连接在新的根结点的左右链接上。操作完成后树高加1，如下图所示。显而易见此次变换的仍保持了2-3树的完美平衡性。\n分解根结点\n1.7 全局性质\n将一个 4- 结点分解为一棵 2-3 树可能有 6 种情况，都总结在了图 3.3.8 中。这个 4- 结点可能是根结点，可能是一个 2- 结点的左子结点或者右子结点，也可能是一个 3- 结点的左子结点、中子结点或者右子结点。 2-3 树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。每个变换都会将 4- 结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。\n这些局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。因为在所有非根结点的上的操作都在保持树完美平衡性的情况下 良好的保持了2-3查找树的有序性。只有在根结点需要转换为一个临时4-结点并分解为3个2-结点时才会使树高加1。\n1.8 测试\n根据上述2-3查找树的原理，我们就可以模拟插入，根据最后生成树的形态判断树的性能。使用两组用例进行测试，一组是键按随机的顺序插入，二组是按键值的正序插入，测试过程和结果如下图所示。\n插入测试\n根据最后的插入结果，我们可以确定的是2-3查找树在最坏的插入情况下仍具有良好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。\n可惜的是，虽然2-3树在逻辑上很好的解决了查找树平衡的问题，但是这种直白的表示方法实现大多数操作并不方便，因为需要处理的情况实在太多。需要维护几种不同类型的结点，将被查找的键与结点中的每一个键比较，将链接等信息从一个结点复制到另外一个结点，将结点从一种数据类型转换到另一种数据类型。实现这些操作不仅需要大量的代码，而且它们的所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一颗查找树的初衷是为了消除最坏插入情况带来的影响，但我们想要这种维持查找树平衡的方法所需要的开销以及代码能够越少越好。\n2.红黑二叉查找树 上文中2-3树插入算法的逻辑思路是非常清晰易于理解的，但是直接实现的额外开销以及代码量都较大。而红黑二叉查找树可以在逻辑上表达实现它，且实现的代码量以及额开销都很小。\n红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外信息（替换3-结点）来表示2-3查找树。\n2.1 替换3-结点\n在红黑二叉查找树中，结点的链接分为两种类型：红链接将两个2-结点连接起来构成一个2-3树中的3-结点，黑链接则是2-3树的普通链接。准确的说，在红黑二叉查找树中用一条左斜的红色链接相连的2个结点来表示2-3树中的3-结点。根据红黑二叉树的定义原理，很多对二叉查找树的操作可以直接拿来使用。而且其他操作和标准的二叉查找树的操作只有很小的区别。对于任意的 2-3 树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示 2-3 树的二叉查找树称为红黑二叉查找树，简称红黑树。\n另一种等价的定义：\n 红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：\n 红链接均为左链接；\n 没有任何一个结点同时和两条红链接相连；(对应4-结点只是临时结点，不能一直存于2-3树中)\n 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。（对应完美平衡的2-3树所有空连接到根的长度相等）\n  满足这样定义的红黑树和相应的 2-3 树是一一对应的。\n 无论我们选择用何种方式去定义它们，红黑树都既是二叉查找树， 也是2-3树。因此，如果我们能够在保持一一对应关系的基础上实现2-3树的插入算法，那么我们就能够将二叉查找树中简洁高效的查找方法 和 2-3树中高效的平衡插入算法的优点结合起来。\n2.2 颜色表示\n为了表示的方便，由于每一个结点都只有一条指向自己的链接（由它的父结点指向它），我们将链接的颜色保存在结点内部一个布尔变量的属性color中。如果指向它的链接为红色，则该属性值为true，黑色则为false。约定空链接为黑色。当说一个结点是红色时，指的是指向它的链接为红色。\n2.3 旋转\n在对红黑二叉查找树进行的某些操作后，可能会出现红色的右链接或者是两条连续的红链接。出现这些情况后我们必须进行一些操作去修复它。旋转就是红黑二叉查找树修复结构性质的操作，旋转分为左旋转，右旋转。\n 左旋转：将一条红色的右链接转化为左链接，具体操作过程和操作方法如下左图所示。操作最终将红色链接指向的结点提升为根结点，原来的根结点成为新根结点的左子结点，原来根结点的右链接指向新根结点原来的左子结点；\n 右旋转：将一条红色的左链接转化为右链接，具体操作与左旋转相反，如下有图所示。\n     左旋 h 的右链接 左旋 h 的左链接          在插入新的键时我们可以使用旋转操作帮助我们保证 2-3 树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的4个重要性质： 有序性，完美平衡性，不存在两条连续的红链接和不存在红色的右链接。在维护红黑树的这些特性时使用的就是左旋转操作，右旋转操作或者是左右旋转操作的组合。再加上一些简单的颜色变换规则就可以很好的实现。\n2.4 向底部的2-结点插入新键\n在红黑树中插入一个结点与二叉查找树插入的方式是相同的，新键都会在树底部新增一个根结点。为了保证红黑树的性质，总是使用红链接将新结点和他的父结点相连。若此时它的父结点是一个2-结点，那么就会出现两种情况。一种是新键小于父结点，这时新结点链接到父结点的红色左链接上成为红色结点。这时刚好可以对应2-3树中的3-结点，不需要变动。如果新键大于父结点，连接在父结点的右链接上，是一个错误的3-结点。这时就需要将这个右红链接左旋转为左红链接修复红黑树。\n2.5 向一个3-结点中插入新键\n这种插入情况又可分为三种子情况：新键小于树中的两个键，在两者之间，或是大于树中的两个键。每种情况中都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。\n 新键大于3-结点中的两个键：因此它被连接到 3- 结点的右链接。此时 树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一棵由三个结点组成、高为 2 的平衡树。它正好能够对应一棵 2-3 树的4-结点分解为3个2接结点。\n 新键小于原树中的两个键：它会被连接到最左边的空链接，这样就产生了两条连续的红链接。此时我们只需要将上层的红链接右旋转即可得到第一种情况。\n 新键介于原树中的两个键之间：这又会产生两条连续的红链接，一条红色左链接接一条红色右链接。此时我们只需要将下层的红链接左旋转即可得到第二种情况。\n  上述3种情况中第三种情况是最复杂的，我们可以将其转换为第二种情况，第二种情况又可以转换为第一种情况。三种情况的具体转换过程如下图从左到右依次所示。\n向一个3-结点中插入新键的三种情况\n2.6 颜色变换\n如果一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将指向它的链接的颜色由黑变红。这个操作对应了2-3树中非根临时4-结点的分解过程。这项操作和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。\n2.7 根结点总是黑色\n颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个 3- 结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。\n2.8 将红链接在树中向上传递\n2-3 树中的插入算法需要我们分解 3- 结点，将中间键插入父结点，如此这般直到遇到一个 2-结点或是根结点。我们所考虑过的所有情况都正是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。具体步骤如下：\n 如果右子结点是红色的而左子结点是黑色的，进行左旋转；\n 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；\n 如果左右子结点均为红色，进行颜色转换。\n  三个步骤与下图对应。\n将红链接在树中向上传递\n2.9 实现\n根据上述的描述，一个红黑二叉树的一般实现如下：\nJava\npackage searching.tree; public class RedBlackBST { private static final boolean RED = true; private static final boolean BLACK = false; private Node root; //根结点 /** * 结点静态内部类 */ private static class Node { private int key; //结点键 private String value; //结点值 private Node left, right; //指向左右子树的连接 private int N; //以该结点为根的子树的结点数 private boolean color; //由其父结点指向它的链接的颜色 Node(int key, String value, int N, boolean color) { this.key = key; this.value = value; this.N = N; this.color = color; } } /** * 判断一个结点的颜色是否为红色 * @param node 结点 */ private boolean isRed(Node node) { if (node == null) return false; return node.color == RED; } /** * 获取当前树的结点数 */ public int size() { return size(root); } private int size(Node node){ if (node == null) return 0; else return node.N; } /** * 红色右链接旋转为红色左链接 * @param oldR 旋转前子树的根节点 * @return 新子树的根节点 */ private Node rotateLeft(Node oldR){ Node newR = oldR.right; oldR.right = newR.left; newR.left = oldR; newR.color = oldR.color; newR.N = oldR.N; oldR.color = RED; oldR.N = 1 + size(oldR.left) + size(oldR.right); return newR; } /** * 红色左链接旋转为红色右链接 * @param oldR 旋转前子数的根节点 * @return 新子树的根节点 */ private Node rotateRight(Node oldR){ Node newR = oldR.left; oldR.left = newR.right; newR.right = oldR; newR.color = oldR.color; newR.N = oldR.N; oldR.color = RED; oldR.N = 1 + size(oldR.left) + size(oldR.right); return newR; } /** * 颜色转换，子结点变黑，父节点变红 * @param node 当前结点 */ private void flipColors(Node node){ node.color = RED; node.left.color = BLACK; node.right.color = BLACK; } /** * 根据键值获取节点的值，节点不存在返回NUll */ public String get(int key) { Node node = root; while (node != null){ if (key \u0026gt; node.key) node = node.right; else if (key \u0026lt; node.key) node = node.left; else return node.value; } return null; } /** * 查找key，命中更新value，否则新建一个结点 * @param key 新插入结点的键 * @param value 新插入结点的值 */ public void put(int key, String value){ root = put(root, key, value); root.color = BLACK; } private Node put(Node node, int key, String value){ //标准插入,和父节点用红链接相连 if(node == null) return new Node(key, value, 1, RED); if (key \u0026gt; node.key) node.right = put(node.right, key, value); else if (key \u0026lt; node.key) node.left = put(node.left, key, value); else node.value = value; //调整红黑树 if (isRed(node.right) \u0026amp;\u0026amp; !isRed(node.left)) node = rotateLeft(node); if (isRed(node.left) \u0026amp;\u0026amp; isRed(node.left.left)) node = rotateRight(node); if (isRed(node.left) \u0026amp;\u0026amp; isRed(node.right)) flipColors(node); node.N = size(node.left) + size(node.right) + 1; return node; } /** * 中序遍历打印所有节点 */ public void inorderPrint(){ inorderPrint(root); } private void inorderPrint(Node node){ if (node == null) return; inorderPrint(node.left); System.out.println(node.key); inorderPrint(node.right); } /** * 查看最右侧路径上的节点值 */ public void printRight(){ Node node = root; while (node != null){ System.out.println(node.value); node = node.right; } } }  除了递归调用后的三条 if语句，红黑树中 put()的递归实现和二叉查找树中 put()的实现完全相同。它们在查找路径上保证了红黑树和 2-3 树的一一对应关系，使得树的平衡性接近完美。三条if语句分别对应上文红链接向上传递的三种情况。\n2.10 性能分析\n首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的。这从它和 2-3树的一一对应关系以及 2-3 树的重要性质可以得到。\n红黑树的最坏情况是它所对应的 2-3 树中构成最左边的路径结点全部都是 3- 结点而其余均为 2- 结点。最左边的路径长度是只包含 2- 结点的路径长度（～ lgN）的两倍。\n和典型的二叉查找树相比，一棵典型的红黑树的平衡性是很好的，在运行中构造的红黑树的路径长度（即查找成本）比初等二叉查找树低 40% 左右。\n几种数据结构实现的查找和插入操作效率的对比：\n   算法（数据结构） 查找(最坏) 插入(最坏) 查找(平均) 插入(平均)     顺序查询（无序链表） N N N/2 N   二分查找（有序数组） lgN N lgN N/2   二叉树查找（BST） N N 1.39lgN 1.39lgN   2-3 树查找（红黑树） 2lgN 2lgN 1.00lgN 1.00lgN    "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/sorting/%E5%A0%86%E6%8E%92%E5%BA%8F/",
	"title": "3. Heap-Sort",
	"tags": [],
	"description": "",
	"content": " 堆排序 1. 优先队列 学习堆排序前，需要先了解优先队列是什么东西，引出数据结构：堆，最后学习堆排序。优先队列和普通的队列一样是一种数据结构，普通队列遵循的原则就是先进先出（FIFO）。而优先队列则是无论入队顺序，当前队列中优先级最高的元素先出。谈到优先级就有两种确定优先级的策略，一是值小的优先级高，二是值大的优先级高。这也就把优先队列分为了两种：\n 最大优先队列：无论入队顺序，当前队列中最大的元素出队列。\n 最小优先队列：无论入队顺序，当前队列中最小的元素出队列。\n  由于二者实现原理类似，下面的优先队列默认是最大优先队列。\n2. 初级实现 在还不知道堆之前，我们用一般的数据结构去实现优先队列也是可行的，但是由于数据结构的限制，算法的性能可能是比较低的。\n1. 基于无序数组实现\n使用无序的数组在插入元素时，可以添加任意添加到数组中一个空位置。在取出最大元素时需要遍历一遍数组找出最大元素，让其与边界元素交换位置然后删除出队。可以添加代码自动的调整数组大小防止元素溢出。\n2. 基于有序数组实现\n在插入每一个新元素时，将比它大的元素都右移一位然后将其插入数组来保持数组的有序性（插入排序）。这样数组中最大的元素总是在数组的最右边，每次让元素出队列直接选择最右边的元素就完了。\n当然上述的两种实现用链表也能实现。基于链表实现在插入，移动元素时有一定的优势，但是在遍历数组时没有数组的效率高，在此不再赘述。\n\r在对于普通队列或栈的实现时，我们使用数组实现，能够使其所有操作都在常数时间内完成。而上述两种初级实现方法，插入元素或删除最大元素的两种操作之一在最坏情况下需要线性的时间来完成，这显然是不怎么好的。而堆这种数据结构能好的实现优先队列，可以将插入元素，删除最大元素消耗的时间降低至对数级，如下表所示（log默认以2为底）。\n   数据结构 插入元素 删除最大元素     有序数组 N 1   无序数组 1 N   堆 logN logN   理想情况 1 1    3. 堆的定义 堆在逻辑结构上是一个完全二叉树，所以有时堆也被称为二叉堆。下面介绍几个概念：\n1. 满二叉树：在每一层上的节点数都达到了最大值，即在第 i 层的节点应为2^(i-1)个节点。\n2. 完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。也就是说，一颗满二叉树，或缺失掉右下角一部分节点的满二叉树就是一颗完全二叉树。\n3. 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 不难看出在一课堆有序的二叉树中，最大的元素就是二叉树的根节点。\n4. 堆的表示\n在一般情况下我们表示一颗二叉树都需要在每一个元素中放置3个指针，一个是指向父节点，另外两个指向其两个子节点，方便我们操作二叉树的元素。但是由于堆是一颗完全二叉树，事情就简化了许多，我们仅使用一个数组就可以表示一个堆: 我们将整个堆按层级顺序放置到一个数组中，根节点在位置1，根节点左子节点在位置2，右子节点在位置3，依次类推 。这样放置后我们可以容易的得到结论：在一个数组表示堆中，位置 k 的结点的父结点的位置为k/2，而它的两个子结点的位置则分别为 2k 和 2k+1。 这样我们在不使用指针的情况下，也可以找到一个节点的父节点，以及其两个子节点。而且也大幅提高了查找元素的性能。\n5. 堆实现优先队列 1. 堆的有序化\n前面我们提到了堆有序的概念就是：当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。而我们将一个不满足堆有序定义的堆变为一个堆有序的堆的过程就称为堆有序化。 而堆不满足堆有序的原因可分为两个种。 一是：元素的父节值点小于它，它需要上浮来使堆有序。二是：元素节点值小于其两个子节点或两个子节点其中之一，它需要下沉来使堆有序。\n1.1 上浮实现\n//元素上浮 private void swim(int k){ while (k\u0026gt;1 \u0026amp;\u0026amp; (pq[k/2] \u0026lt; pq[k])){ exch(k/2, k); k = k/2; } }  1.2 下沉实现\n //元素下沉 private void sink(int k){ while (2*k \u0026lt;= N){ int j = 2*k; if (j \u0026lt; N \u0026amp;\u0026amp; pq[j]\u0026lt;pq[j+1]) j++; //此时 j 为位置为 k 节点的子节点中值较大节点的索引 if (pq[k] \u0026gt; pq[j]) break; exch(k, j); k = j; } }  有了上述两个操作，我们就可以保证在元素变化使，仍然可以让堆重新堆有序化。\n2. 堆实现优先列队\n根据堆的定义以及其性质，我们就可以很轻松高效的实现优先队列。在插入元素时，将新元素放置在末尾，然后使用swim()函数去操作它使得新堆达到堆有序。在删除元素时，直接删除值最大根节点，然后将末尾节点放置到根节点的位置，最后使用sink()函数使其下沉到合适位置使新堆达到堆有序。具体实现如下：\nJava\n/** * 基于堆实现的优先队列 */ public class MaxPQ { private int[] pq; private int N = 0; public MaxPQ(int maxN){ pq = new int[maxN+1]; } //返回优先队列长度 public int size(){ return N; } //交换元素位置 private void exch(int i, int j){ int tmp = pq[i]; pq[i] = pq[j]; pq[j] = tmp; } //元素上浮, 参考上文 private void swim(int k); //元素下沉，参考上文 private void sink(int k); //插入元素 public void insert(int v){ pq[++N] = v; swim(N); } //删除最大元素 public int delMax(){ int max = pq[1]; //有序化堆 exch(1, N--); pq[N+1] = 0; sink(1); return max; } }  6. 堆排序 我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最大元素的优先队列， 然后再重复调用删除最大元素的操作来将它们按顺序删去。用无序数组实现的优先队列这么做相当于进行一次选择排序。用基于堆的优先队列这样做等同于哪种排序？一种全新的排序方法！下面我们就用堆来实现一种经典而优雅的排序算法——堆排序。\n堆排序在操作上分为两个步骤：\n 用待排序数组元素构造一个堆有序的堆。\n 取出最大元素，将最后一个元素放置到根节点位置，然后调用sink()函数将新堆有序化。重复此步骤直到数组元素取尽。\n  明白了这两个步骤后大致也就理解了堆排序的原理。其中步骤1构建一个堆有序的堆的方法有几个，可能最容易想到的就是从左至右扫描数组，使用 swim() 来保证堆有序。但是有一个更聪明高效的方法是使用 sink() 函数，由于完全二叉树的叶子节点数总是大于等于非叶子节点数这个完全二叉树的性质，使用sink()函数只需要处理一遍非叶子节点，所以我们就只需要扫描数组的一半元素。唯一的不足就是sink()的每次循环会有两次比较，比swim()多一次。完整实现的堆排序如下。\nJava\npublic class HeapSort { public static void sort(int[] a){ int N = a.length; //堆有序化 for (int k = N/2; k \u0026gt;= 1; k--){ sink(a, k, N); } //下沉排序排序，销毁堆 while (N \u0026gt; 1){ exch(a, 1, N--); sink(a, 1, N); } } //元素下沉 private static void sink(int[] a, int k, int N){ while (2*k \u0026lt;= N){ int j = 2*k; //比较时索引减一，将索引位置由1 ~ n 映射到 0 ~ n-1 if (j \u0026lt; N \u0026amp;\u0026amp; a[j-1] \u0026lt; a[j]) j++; //此时 j 为位置为 k 节点的子节点中值较大节点的索引 if (a[k-1] \u0026gt; a[j-1]) break; exch(a ,k, j); k = j; } } //交换元素位置 private static void exch(int[] a, int i, int j){ //换位置索引减一，将索引位置由1 ~ n 映射到 0 ~ n-1 i -= 1; j -= 1; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } }  7. 堆排序的优缺点 优点：\n 堆排序的效率与快排、归并相同，都达到了基于比较的排序算法效率的峰值（时间复杂度为O(nlogn)）\n 只需要O(1)的辅助空间了，既最高效率又最节省空间。\n 堆排序效率相对稳定，不像快排在最坏情况下时间复杂度会变成O(n^2)），所以无论待排序序列是否有序，堆排序的效率都是O(nlogn)不变（注意这里的稳定特指平均时间复杂度=最坏时间复杂度，不是那个“稳定”，因为堆排序本身是不稳定的）\n  缺点：\n现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。\n但是虽然有这一致命缺点，但是由于其优点太过于吸引人，在一些特殊的场景仍是一种非常重要，优秀的算法。\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/mybatis%E6%98%A0%E5%B0%84%E5%99%A82/",
	"title": "3. Mybatis映射器2",
	"tags": [],
	"description": "",
	"content": " Mybatis 映射器中除了实现增删改查的四大标签元素，还有一些辅助的标签元素来让程序更好更便捷的与数据库交互。分别为：, , , 。其中 resultMap是映射器中最重要最强大的的标签元素，需要多一些的篇幅来记录它，这篇博客先记录其他的三个元素。\n1. \u0026lt;sql\u0026gt;元素  标签元素可以用来定义一段 Sql 代码段，这些代码可以被包含在其他标签元素内的 Sql 语句中。更重要的是，它可以在加载时被静态的设置参数，在被不同的语句包含时可以设置不同的参数到参数占位符上。例如：\n\u0026lt;sql id=\u0026quot;userColumns\u0026quot;\u0026gt; ${user}.id,${user}.username,${user}.password \u0026lt;/sql\u0026gt; \u0026lt;/sql\u0026gt;  #{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值；\\${ }是字符串替换， MyBatis在处理\\${ }时,它会将sql中的\\${ }替换为变量的值。使用${ }可能会导致sql注入，不利于系统的安全性！\n\r这样声明后这个 Sql 语句就可以就可以被包含在其他标签下的 Sql 语句中了。例如：\n\u0026lt;select id=\u0026quot;selectUsers\u0026quot; resultType=\u0026quot;map\u0026quot;\u0026gt; select \u0026lt;include refid=\u0026quot;userColumns\u0026quot;\u0026gt;\u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;u1\u0026quot;/\u0026gt;\u0026lt;/include\u0026gt;, \u0026lt;include refid=\u0026quot;userColumns\u0026quot;\u0026gt;\u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;u2\u0026quot;/\u0026gt;\u0026lt;/include\u0026gt; from some_table u1 cross join some_table u2 \u0026lt;/select\u0026gt;  2. 缓存元素 Mybatis 内置了一个强大的事务查询缓存机制，可以非常方便的配置和定制。在默认情况下，Mybatis 只启用了本地的会话缓存，仅对一个会话中的数据进行缓存。若需要启用全局二级缓存，只需要在映射器文件中添加一行：\n\u0026lt;cache/\u0026gt;  添加这一个标签元素后，会起到如下效果：\n 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。  缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。\n\r上述效果只是 元素的默认配置，可以通过修改 元素属性来修改配置。 的主要属性如下表：\n   属性 描述     eviction 指定缓存的清除策略，共有四种四种：LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。默认的清除策略是 LRU。   flushInterval 指定缓存的刷新时间间隔，单位为毫秒(ms)。默认为不设置，缓存只会在调用语句后被刷新。   size 指定缓存引用数目，默认值为1024   readOnly 指定缓存对象是否只能读取，属性可以被设置为 true 或 false。默认为 false    全局二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。\n\r缓存的配置和缓存实例会被绑定到 映射器 文件的命名空间中。 因此，同一命名空间中的所有语句和缓存将通过命名空间绑定在一起。每一条语句都可以通过两个属性 定义与缓存的交互方式，如下所示：\n\u0026lt;select ... flushCache=\u0026quot;false\u0026quot; useCache=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;insert ... flushCache=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;update ... flushCache=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;delete ... flushCache=\u0026quot;true\u0026quot;/\u0026gt;  在某些情况下，我们根据自己项目的需求希望有一条 select 语句不使用缓存可以设置其 useCache 为 false ，同样如果希望一条 Insert 语句执行不刷新缓存可以设置其 flushCache 为 false 。\n2. 缓存引用元素 它可以在一个映射器文件中，引用其他映射器文件中的缓存配置。配置也较为简单，如下。\n\u0026lt;cache-ref namespace=\u0026quot;引用缓存的命名空间\u0026quot;/\u0026gt;  "
},
{
	"uri": "https://compass-ak.gitee.io/android/activity/activity%E7%8A%B6%E6%80%81%E7%9A%84%E4%BF%9D%E5%AD%98/",
	"title": "3. Activity状态的保存",
	"tags": [],
	"description": "",
	"content": " 1. Activity的状态 在Android系统中运行的Activity基本上以下面三种状态存在。\n 继续 ：此时 Activity 位于屏幕前台并具有用户焦点。（有时也将此状态称作“运行中”。）\n 暂停 ：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。也就是说，另 一个 Activity 显示在此 Activity 上方，并且该 Activity 部分透明或未覆盖整个屏幕。 暂停的 Activity 处于完全活动状态（Activity 对象保留在内存中，它保留了所有状态和 成员信息，并与窗口管理器保持连接），但在内存极度不足的情况下，可能会被系统终止。\n 停止 ：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。 已停止的 Activity 同样仍处于活动状态（Activity 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。\n  如果 Activity 处于暂停或停止状态，系统可通过要求其结束（调用其 finish() 方法）或直接终止其进程，将其从内存中删除。（将其结束或终止后）再次打开 Activity 时，必须重建。\n2. Activity的状态信息的保存 当一个Activity短时间处于暂停或停止状态时，Android系统会会自动保存其状态信息。当用户切换回到此Activity时，Activity的状态信息就会被恢复。但是就如上文说所，当系统急需内存的情况下，Activity就会被销毁，再访问该Activity，访问的就会是一个重建的Activity。如果你没有保存它的状态信息，那么会给用户不良的体验。为了提升App的用户体验就需要保存当前Activity中控件的信息。\n2.1 与Activity状态信息保存的方法  onSaveInstanceState() ：系统在将要销毁一个Activity，会先调用它这个方法。系统会向该方法传递一个 Bundle，您可以在其中使用 putString() 和 putInt() 等方法以名称-值对形式保存有关 Activity 状态的信息。然后，如果系统终止您的应用进程，并且用户返回您的 Activity，则系统会重建该 Activity，并将 Bundle 同时传递给 onCreate() 和 onRestoreInstanceState()。\n onCreate()：系统在每次构建一个Activity时都会调用此方法，你可以使用此方法来恢复Activity的状态信息。如果没有状态信息需要恢复，则传递给您的 Bundle 是空值（如果是首次创建该 Activity，就会出现这种情况）。\n onRestoreInstanceState()：系统在销毁 Activity 后重建 Activity时，会调用此方法。你可以使用此方法来恢复Activity的状态信息。\n  无法保证系统会在销毁您的 Activity 前调用 onSaveInstanceState()，因为存在不需要保存状态的情况（例如用户使用“返回”按钮离开您的 Activity 时，因为用户的行为是在显式关闭 Activity）。 如果系统调用 onSaveInstanceState()，它会在调用 onStop() 之前，并且可能会在调用 onPause() 之前进行调用。\n\r不过，即使您什么都不做，也不实现 onSaveInstanceState()，Activity 类的 onSaveInstanceState() 默认实现也会恢复部分 Activity 状态。具体地讲，默认实现会为布局中的每个 View 调用相应的 onSaveInstanceState() 方法，让每个视图都能提供有关自身的应保存信息。Android 框架中几乎每个小部件都会根据需要实现此方法，以便在重建 Activity 时自动保存和恢复对 UI 所做的任何可见更改。例如，EditText 小部件保存用户输入的任何文本，CheckBox 小部件保存复选框的选中或未选中状态。您只需为想要保存其状态的每个小部件提供一个唯一的 ID（通过 android:id 属性）。如果小部件没有 ID，则系统无法保存其状态。实现上述方法时，会默认调用父Activity保存状态信息的方法，如下。\n@Override public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) { super.onSaveInstanceState(outState, outPersistentState); } @Override protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); }  由于 onSaveInstanceState() 的默认实现有助于保存 UI 的状态，因此如果您为了保存更多状态信息而替换该方法，应始终先调用 onSaveInstanceState() 的父类实现，然后再执行任何操作。 同样，如果您替换 onRestoreInstanceState() 方法，也应调用它的超类实现，以便默认实现能够恢复视图状态。\n1.您还可以通过将 android:saveEnabled 属性设置为 \u0026ldquo;false\u0026rdquo; 或通过调用 setSaveEnabled() 方法显式阻止布局内的视图保存其状态。您通常不应将该属性停用，但如果您想以不同方式恢复 Activity UI 的状态，就可能需要这样做。\n\r2.1 与Activity状态信息保存测试 有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。 发生此类变化时，Android 会重建运行中的 Activity（系统调用 onDestroy()，然后立即调用 onCreate()）。此行为旨在通过利用您提供的备用资源（例如适用于不同屏幕方向和屏幕尺寸的不同布局）自动重新加载您的应用来帮助它适应新配置。\n 注释掉方法中调用父类的super.onSaveInstanceState(outState, outPersistentState);super.onRestoreInstanceState(savedInstanceState);方法调用后当手机旋转后，EditView中输入的数据丢失，如下图。             取消注释后信息正常保存。            2.由于无法保证系统会调用 onSaveInstanceState()，因此您只应利用它来记录 Activity 的瞬态（UI 的状态）— 切勿使用它来存储持久性数据，而应使用 onPause() 在用户离开 Activity 后存储持久性数据（例如应保存到数据库的数据）。\n\r"
},
{
	"uri": "https://compass-ak.gitee.io/java/",
	"title": "Java",
	"tags": [],
	"description": "",
	"content": " JAVA NOTES "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/spring/",
	"title": "Spring",
	"tags": [],
	"description": "",
	"content": " Chapter 3.3 Spring Notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/",
	"title": "3. Tomcat服务器目录结构",
	"tags": [],
	"description": "",
	"content": "## []()Tomcat服务器目录结构\n如下图所示：\n我们看到的目录\n目录存放文件主要功能图：\n图片素材来自百度，侵删。\n"
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/graphs/sp/",
	"title": "4. Shortest Path",
	"tags": [],
	"description": "",
	"content": " 最短路径 在简单的无向图模型中，我们使用 广度优先搜索 可以找到一个顶点到另一个顶点的最短路径（含顶点最少）。但是在加权图中情况有了很大的不同，需要考虑边的权重，这也更贴合许多实际问题。在加权图中的最短路径又可以理解为：找到从一个顶点到达另一个顶点的成本最小的路径。\n为了能够解决更多的实际问题，方便提取问题的抽象模型。我们讨论最短路径基于的图模型一定要具有一般性，考虑更多的变量。也就是加权有向图模型，每一条路径都是有向的，而且有一个和路径关联的权重。\n1. 加权有向图数据结构 考虑到加权有向图于有向图有一定类似，而且边具有权重，会有很多对边的操作，需要像有向图那样将边抽象实现。有向边的数据结构比无向边简单很多，因为边只有一个方向，指定一个顶点为起点，另一个为终点就行了。加权有向边的具体实现如下：\nDirectedEdge\npublic class DirectedEdge { private final int v; // 边起点 private final int w; // 边终点 private final double weight; // 边权重 public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } public double weight(){ return weight; } public int from(){ return v; } public int to(){ return w; } public String toString() { return String.format(\u0026quot;%d-\u0026gt;%d %.2f\u0026quot;, v, w, weight); } }  加权有向图数据结构与加权无向图 EdgeWeightedGraph 类似，区别在于边具有方向后在 addEdge() 只需要在起点索引对应邻接表中添加边。以及成员属性是加权无向边还是加权有向边的区别。加权有向图具体实现如下：\nEdgeWeightedDigraph\npublic class EdgeWeightedDigraph { private final int V; // 顶点总数 private int E; // 边的总数 private List\u0026lt;ArrayList\u0026lt;DirectedEdge\u0026gt;\u0026gt; adj; // 邻接表 public EdgeWeightedDigraph(int V) { this.V = V; this.E = 0; adj = new ArrayList\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; V; v++) adj.add(new ArrayList\u0026lt;\u0026gt;()); } public EdgeWeightedDigraph(BufferedReader reader) throws IOException { this(Integer.parseInt(reader.readLine())); // 读取 V int E = Integer.parseInt(reader.readLine()); // 读取 E for (int i = 0; i \u0026lt; E; i ++){ String str = reader.readLine(); String[] edge= str.split(\u0026quot; \u0026quot;); int v = Integer.parseInt(edge[0]); int w = Integer.parseInt(edge[1]); double weight = Double.parseDouble(edge[2]); addEdge(new DirectedEdge(v, w, weight)); // 添加边 } } /** * 在有向边起点对应的邻接表添加一条边 * @param e 有向边 */ public void addEdge(DirectedEdge e) { adj.get(e.from()).add(e); E++; } /** * 查询所有从顶点出的边。 * @param v 顶点 * @return 所有从顶点出的边 */ public List\u0026lt;DirectedEdge\u0026gt; adj(int v){ return adj.get(v); } public List\u0026lt;DirectedEdge\u0026gt; edges(){ List\u0026lt;DirectedEdge\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;DirectedEdge\u0026gt; es : adj){ edges.addAll(es); } return edges; } public int V() { return V; } public int E() { return E; } }  2. 最短路径的性质 定义：在一幅加权有向图中，从顶点 s 到顶点 t 的最短路径是所有从 s 到 t 的路径中的权重最小者。\n基于上述的加权有向图数据结构的最短路径具有下列值得注意的几个点：\n 路径是有向的。\n 权重不一定等价于距离。\n 指定起点后，不一定所有顶点都可达。\n 边的权重可以为负值。\n 最短路径不一定是唯一的。\n 最短路径一般都是简单的。\n 可能存在平行边和自环。\n  3. 最短路径算法理论基础 在计算加权有向图的多数常用算法都是基于 松弛（relaxation）的简单操作。松弛分为边的松弛，顶点的松弛。\n3.1 最短路径的数据结构\n根据我们对问题的定义，我们需要求出给定起点的加权有向图到所有可达顶点的最短路径。其计算结果是是一棵 最短路径树 （给定一幅加权有向图和一个顶点 s，以 s 为起点的一棵最短路径树是图的一幅子图，它包含 s和从 s 可达的所有顶点。这棵有向树的根结点为 s，树的每条路径都是有向图中的一条最短路径）\n一般来说，从 s 到一个顶点有可能存在两条长度相等的路径。如果出现这种情况，可以删除其中一条路径的最后一条边。如此这般，直到从起点到每个顶点都只有一条路径相连（即一棵树）。\n记录表示最短路径所需的数据结构很简单，和以前深度优先搜索，广度优先搜索保存路径类似：使用一个由顶点索引的 DirectedEdge 对象的父链接数组 edgeTo[]，其中 edgeTo[v]的值为树中连接 v 和它的父结点的边（也是从s到v的最短路径上的最后一条边）。\n最后为了权重的比较和计算需要一个由顶点索引的数组 distTo[]，其中 distTo[v] 为从 s 到 v 的已知最短路径的长度。我们约定， edgeTo[s] 的值为 null， distTo[s] 的值为 0，从起点到不可达的顶点的距离均为 Double.POSITIVE_INFINITY。\n3.2 边的松弛\n边的放松操作是一项非常容易实现的重要操作，它是实现最短路径算法的基础。\n定义： 放松边 v → w 意味着检查从 s 到 w 的最短路径是否是先从 s 到 v，然后再由 v 到 w。如果是，进行下一步。经由 v 到达 w 的最短路径是 distTo[v] 与 e.weight() 之和，如果这个值不小于 distTo[w]，则称这条边失效了并将它忽略；如果这个值更小，就更新 distTo[w] 数据。一般实现如下：\nprivate void relax(DirectedEdge e){ int v = e.from(), w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; } }  松弛这个术语来自于用一根橡皮筋沿着连接两个顶点的路径紧紧展开的比喻：放松一条边就类似于将橡皮筋转移到一条更短的路径上，从而缓解了橡皮筋的压力。如果 relax() 改变了和边 e 相关的顶点的 distTo[e.to()] 和 edgeTo[e.to()] 的值，就称 e 的放松是成功的。\n3.3 顶点的松弛\n实际上为了方便操作，实现会放松从一个给定顶点指出的所有边。也就是顶点的松弛，一般实现如下：\nprivate void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)){ int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; } } }  3.4 最优性条件\n命题 P（最短路径的最优性条件） 。令 G 为 一 幅 加 权 有 向 图， 顶 点 s 是 G 中 的 起 点， distTo[] 是一个由顶点索引的数组，保存的是 G 中路径的长度。对于从 s 可达的所有顶点 v， distTo[v] 的值是从 s 到 v 的某条路径的长度，对于从 s 不可达的所有顶点 v，该值为无穷大。 当且仅当对于从 v 到 w 的任意一条边 e，这些值都满足 distTo[w]\u0026lt;=distTo[v]+e.weight() 时（换句话说，不存在有效边时），它们是最短路径的长度。 证明。假设 distTo[w] 是从 s 到 w 的最短路径。如果对于某条从 v 到 w 的边 e 有 distTo[w]\u0026gt; distTo[v]+e.weight()， 那 么 从 s 到 w（ 经 过 v） 且 经 过 e 的 路 径 的 长 度 必 然 小 于 distTo[w]，矛盾。因此最优性条件是必要的。 要证明最优性条件是充分的，假设 w 是从 s 可达的且 s=v0 → v1 → v2... → vk=w 是从 s 到 w 的 最短路径，其权重为 OPTsw。对于 1 到 k 之间的 i，令 ei 表示 vi-1 到 vi 的边。根据最优性条件， 可以得到以下不等式： distTo[w] = distTo[vk] \u0026lt;= distTo[vk-1] + ek.weight() distTo[vk-1] \u0026lt;= distTo[vk-2] + ek-1.weight() ... distTo[v2] \u0026lt;= distTo[v1] + e2.weight() distTo[v1] \u0026lt;= distTo[s] + e1.weight() 综合这些不等式并去掉 distTo[s]=0.0，得到： distTo[w] \u0026lt;= e1.weight() + ... + ek.weight() = OPTSW. 现在， distTo[w] 为从 s 到 w 的某条边的长度，因此它不可能比最短路径更短。所以我们有以 下不等式： OPTSW \u0026lt;= distTo[w] \u0026lt;= OPTSW 且等号必然成立  4. Dijkstra 算法 Dijkstra 算法采用了于 Prim 算法类似的方法来计算最短路径树。首先将 distTo[s]初始化为 0， distTo[] 中的其他元素初始化为正无穷。然后将 distTo[] 最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的 distTo[] 值均为无穷大。\n要实现 Dijkstra 算法，除了 distTo[] 和 edgeTo[] 数组之外还需要一条索引优先队列 pq，以保存需要被放松的顶点并确认下一个被放松的顶点。使用与 prim 算法类似的结点作为优先队列的元素。两种之间的原理区别是： Prim 算法每次添加的都是离树最近的非树顶点， Dijkstra算法每次添加的都是离起点最近的非树顶点。\nDijkstraSP 的实现如下：\npublic class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; private PriorityQueue\u0026lt;Node\u0026gt; pq; private static class Node{ int v; // 顶点 Double weight; // 连接顶点 v 和起点的最佳边的权重 Node(int v, Double weight){ this.v = v; this.weight = weight; } @Override public boolean equals(Object obj){ if (this == obj) return true; if (!(obj instanceof Node)) return false; Node node = (Node)obj; return this.v == node.v \u0026amp;\u0026amp; this.weight.equals(node.weight); } } public DijkstraSP(EdgeWeightedDigraph g, int s){ edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; pq = new PriorityQueue\u0026lt;\u0026gt;(Comparator.comparing(o -\u0026gt; o.weight)); for (int v = 0; v \u0026lt; g.V(); v++) { distTo[v] = Double.POSITIVE_INFINITY; } distTo[s] = 0.0; pq.add(new Node(s, 0.0)); while (!pq.isEmpty()) relax(g, pq.poll().v); } /** * 顶点放松函数，寻找顶点到起点的最短（权重）路径 * @param g 加权有向图 * @param v 当前顶点 */ private void relax(EdgeWeightedDigraph g, int v){ for (DirectedEdge e : g.adj(v)){ int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; Node node = new Node(w, distTo[w]); for (Object obj : pq.toArray()) { if (((Node) obj).v == node.v) { pq.remove(obj); break; } } pq.add(node); } } } /** * 起点到 v 最小权重路径的权重 * @param v 当前顶点 * @return 权重 */ public double distTo(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u0026lt; Double.POSITIVE_INFINITY; } /** * 获取起点到 v 最小权重路径边的集合 * @param v 当前顶点 * @return 最小权重路径边的集合 */ public List\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; List\u0026lt;DirectedEdge\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); for (DirectedEdge x = edgeTo[v]; x != null ; x = edgeTo[x.from()]) { path.add(x); } Collections.reverse(path); return path; } }  Dijkstra 算法的实现使用顶点松弛的方法每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 w 且它是到 s 最近的顶点。\n5. 无环加权有向图中的最短路径算法 许多应用中的加权有向图都是不含有有向环的，解决这些特殊的问题我们可以改良出更好更快的算法，能够处理负权重的边，能够在线性时间内解决单点最短路径问题。\n算法主要步骤是将顶点的放松和拓扑排序结合起来，得到一种解决无环加权有向图中的最短路径问题的算法：首先，将 distTo[s] 初始化为 0，其他 distTo[] 元素初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。\n正确性证明：\n命题 S。按照拓扑顺序放松顶点，就能在和 E+V 成正比的时间内解决无环加权有向图的单点最 短路径问题。 证明。每条边 v → w 都只会被放松一次。当 v 被放松时，得到： distTo[w]\u0026lt;= distTo[v]+e. weight()。在算法结束前该不等式都成立，因为 distTo[v] 是不会变化的（因为是按照拓扑 顺序放松顶点，在 v 被放松之后算法不会再处理任何指向 v 的边）而 distTo[w] 只会变小（任 何放松操作都只会减小 distTo[] 中的元素的值）。因此，在所有从 s 可达的顶点都被加入到 树中后，最短路径的最优性条件成立，命题 Q 也就成立了。时间上限很容易得到：命题 G 告诉 我们拓扑排序所需的时间与 E+V 成正比，而在第二次遍历中每条边都只会被放松一次，因此算 法总耗时与 E+V 成正比。  根据上述算法原理实现的 AcyclicSP 如下。该实现中不需要布尔数组 marked[]：因为是按照拓扑顺序处理无环有向图中的顶点，所以不可能再次遇到已经被放松过的顶点。在拓扑排序后，构造函数会扫描整幅图并将每条边放松一次。在已知加权图是无环的情况下，它是找出最短路径的最好方法。\npublic class AcyclicSP { private DirectedEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightedDigraph g, int s){ edgeTo = new DirectedEdge[g.V()]; distTo = new double[g.V()]; for (int v = 0; v \u0026lt; g.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; DepthFirstOrder order = new DepthFirstOrder(g); // 按照顶点拓扑排序遍历图 for (int v : order.reversePost()){ relax(g, v); } } /** * 顶点放松函数，寻找顶点到起点的最短（权重）路径 * @param g 加权有向图 * @param v 当前顶点 */ private void relax(EdgeWeightedDigraph g, int v){ for (DirectedEdge e : g.adj(v)){ int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; } } } /** * 起点到 v 最小权重路径的权重 * @param v 当前顶点 * @return 权重 */ public double distTo(int v) { return distTo[v]; } public boolean hasPathTo(int v) { return distTo[v] \u0026lt; Double.POSITIVE_INFINITY; } /** * 获取起点到 v 最小权重路径边的集合 * @param v 当前顶点 * @return 最小权重路径边的集合 */ public List\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; List\u0026lt;DirectedEdge\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); for (DirectedEdge x = edgeTo[v]; x != null ; x = edgeTo[x.from()]) { path.add(x); } Collections.reverse(path); return path; } }  对于最短路径问题，由于图的“无环”能够极大地简化问题的论断,基于拓扑排序的方法比 Dijkstra 算法快的倍数与 Dijkstra 算法中所有优先队列操作的总成本成正比。\n5.1 最长路径\n无环加权有向图中的单点最长路径 : 给定一幅无环加权有向图（边的权重可能为负）和一个起点 s，是否存在一条从 s到给定的顶点 v的路径使得顶点 s 到 v 的权重最大。\n使用 AcyclicSP 的解决思路是：复制原始无环加权有向图得到一个副本并将副本中的所有边的权重取相反数。这样，副本中的最短路径即为原图中的最长路径。要将最短路径问题的答案转换为最长路径问题的答案，只需将方案中的权重变为正值即可。根据命题 S 立即可以得到算法所需的时间。\n和它形成鲜明对比的是，在一般的加权有向图（边的权重可能为负）中寻找最长简单路径的已知最好算法在最坏情况下所需的时间是指数级别的。出现环的可能性似乎使这个问题的难度以指数级别增长。\n5.2 并行任务调度\n优先级限制下的并行任务调度：给定一组需要完成的任务和每个任务所需的时间，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在若干相同的处理器上（数量不限） 安排任务并在最短的时间内完成所有任务。\n在有向图的模型默认只有单个处理器：将任务按照拓扑顺序排序，完成任务的总耗时就是所有任务所需要的总时间。现在假设有足够多的处理器并能够同时处理任意多的任务，受到的只有优先级的限制。令人兴奋的是，正好存在一种线性时间的算法——一种叫做“关键路径“的方法能够证明这个问题与无环加权有向图中的最长路径问题是等价的。\n假设任意可用的处理器都能在任务所需的时间内完成它，那么我们的重点就是尽早安排每一个任务。由优先级限制指定的每一列任务都代表了调度方案的一种可能的时间下限。如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的 关键路径 ，因为在这份任务序列中任何任务的启动延迟都会影响到整个项目的完成时间。\n解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点 s 和一个终点 t 且每个任务都对应着两个顶点（一个起始顶点和一个结束顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制 v → w，添加一条从 v 的结束顶点指向 w 的起始顶点的权重为零的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。\n6. 一般加权有向图中的最短路径问题 AcyclicSP 实现的算法虽然非常快达到了线性级别，但是它要求图是无环的。以至于它无法处理一部分有环的加权有向图的问题。我们需要找到一种既可能含有环也可能含有负权重的边的加权有向图中的最短路径算法。\n由于具有父权重的边，以及负权重的环。我们需要更新一下对最短路径的认知，当存在负权重的边时，权重较小的路径含有的边可能会比权重较大的路径更多。在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而绕弯。这种效应使得我们要将查找“最短”路径的感觉转变为对算法本质的理解。\n6.1 负权重环的检测\n负权重环的检测是算法设计需要解决的一个重要问题，按照以往的算法流程走，算法会在负权重环中陷入无限循环。如何避免这种情况是算法实现的关键。一般使用以下策略检测负权重环：\n 添加一个变量 cycle 和一个私有函数 findNegativeCycle()。如果找到负权重环，该方法会将cycle 的值设为含有环中所有边的一个集合（如果没有找到则设为 null）。\n 每调用 V 次 relax() 方法后即调用 findNegativeCycle() 方法。\n  这种方法能够保证构造函数中的循环必然会终止。另外，用例可以调用 hasNegativeCycle()来判断是否存在从起点可达的负权重环（并用 negativeCycle() 来获取这个环）\n具体的 findNegativeCycle() 实现原理是：首先，算法会使用一个加权有向边数组 DirectedEdge[] edgeTo 来存储起点到各顶点的最短路径（权重最小），如果算法访问到了一个负权重环，那么它一定会出现在 edgeTo 中（正权重环就不会，因为绕环一圈权重不会减小，也就根本不可能会绕）。这时我们就可以使用一般的环检测方法来检测它，只需要扩展深度优先搜索中的 DirectedCycle 就可以完成。具体实现如下：\nprivate void findNegativeCycle(){ EdgeWeightedDigraph spt = new EdgeWeightedDigraph(edgeTo.length); for (DirectedEdge e : edgeTo) if (e != null) spt.addEdge(e); EdgeWeightedCycleFinder cf = new EdgeWeightedCycleFinder(spt); cycle = cf.cycle(); }  EdgeWeightedCycleFinder 由 DirectedCycle 扩展而来。\n6.2 Bellman-Ford 算法实现\n完成了最重要的负权重环检测，一般加权有向图中的最短路径算法 Bellman-Ford 的其它地方和上述最短路径算法类似。不同的地方主要有以下两点：\n 一条用来保存即将被放松的顶点的队列 queue；\n 一个由顶点索引的 boolean 数组 onQ[]，用来指示顶点是否已经存在于队列中，以防止将顶点重复插入队列。\n  BellmanFordSP 的具体实现如下。\npublic class BellmanFordSP { private double[] distTo; // 从起点到某个顶点的路径长度 private DirectedEdge[] edgeTo; // 从起点到某个顶点的最后一条边 private boolean[] onQ; // 该顶点是否存在于队列中 private Queue\u0026lt;Integer\u0026gt; queue; // 正在被放松的顶点 private int cost; // relax()的调用次数 private List\u0026lt;DirectedEdge\u0026gt; cycle; // edgeTo[]中的是否有负权重环 public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; onQ = new boolean[G.V()]; queue = new ArrayDeque\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; queue.add(s); onQ[s] = true; while (!queue.isEmpty() \u0026amp;\u0026amp; !hasNegativeCycle()) { int v = queue.poll(); onQ[v] = false; relax(G, v); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)){ int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (!onQ[w]) { queue.add(w); onQ[w] = true; } } if (cost++ % G.V() == 0) findNegativeCycle(); } } private void findNegativeCycle() // 如6.1所示 public boolean hasNegativeCycle(){ return cycle != null; } public Iterable\u0026lt;DirectedEdge\u0026gt; negativeCycle(){ return cycle; } }  Bellman-Ford 算法的实现修改了 relax() 方法，将被成功放松的边指向的所有顶点加入到一条FIFO 队列中（队列中不出现重复的顶点）并周期性地检查 edgeTo[]表示的子图中是否存在负权重环（cost++ % G.V() == 0）\n7. 几种最短路径算法的比较    算　法 局　限 路径长度的比较次数（一般） 路径长度的比较次数（最坏） 所需空间 优　势     Dijkstra 算法（即时版本） 边的权重必须为正 ElogV ElogV V 最坏情况下仍有较好的性能   拓扑排序法 只适用于无环加权有向图 E+V E+V V 是无环图中的最优算法   Bellman-Ford算法（基于队列） 不能存在负权重环 E+V VE V 适用领域广泛    "
},
{
	"uri": "https://compass-ak.gitee.io/algorithms/searching/%E6%95%A3%E5%88%97%E8%A1%A8/",
	"title": "4. Hash-Tables",
	"tags": [],
	"description": "",
	"content": " 散列表 使用基于红黑二叉查找树实现的查找算法，在平均情况下可以达到logN的效率。算法时间复杂度中，最小最优的就是常数级别的复杂度。有没有一种算法可以突破logN的查询复杂度到达常数级别的效率？答案就是散列表（Hash-Tables）\n使用散列表需要将键转化为数组的索引，进而使用这个索引实现对数组中键值对的快速访问。这就产生了两个需要解决的问题：\n 怎么由键转化为数组索引；\n 如何处理转化后索引的冲突。\n  将键转化为数组的索引需要一个 散列函数 ， 散列函数 的理想目的是将可能用例的不同的键都可以转化为不同的索引值。但是这样的散列函数目前是不存在的，所以转化时一定会出现索引冲突的情况，也就是多个键转化后对应一个索引值。在散列查找中解决索引冲突一般使用两种方法： 拉链法 和 线性探测法 。\n1. 散列函数 散列函数用于解决上述第一个问题，将键转化为数组索引。如果我们有一个长度为M的数组用于存储键值对，那么我们就需要一个可以将任意键值转化为该数组的索引范围（ [0, M-1] ）内整数的 散列函数 。散列函数应该是能使所有键分布均匀且易于计算。\n散列函数的设计与键的类型有很大的关系。确切的说，对于每一种类型的键我们都需要寻找一个与之对应的散列函数。\n1.1 正整数\n将整数散列最常用的方法是： 除留余数法 。选择一个大小的为素数 M 的数组，对于任意的整数键 k，计算 k 除 M 的余数作为在数组中的索引。此散列函数能很有效的将键散布在 [0，M-1] 的范围内。选取素数是因为其特殊的数学性质能更好的将键散列，选取其他数（最坏的情况是：如果键是10进制数而数组的大小为10^k，那么散列函数就只能利用到键的后K位数）可能会产生很多的索引冲突。\n1.2 浮点数\n如果键是一个 0 到 1 之间的浮点数，我们可以将其乘以 M 后四舍五入得到一个整数作为其的索引值。此方法便于理解和计算，但是浮点数小数的低位对散列结果的影响没有高位的大。在一些特殊情况：浮点数小数的高位都一样而低位不同，散列的情况就可能非常的糟糕。解决这个问题的方法是将键转化为二进制表示，然后再使用除留取余法。\n1.3 字符串\n对于字符串这种一般较长的键，也可以使用除留取余法。只需要将字符串当作一个较大的整数就行。具体例子如下：\nint hash = 0; for (int i = 0; i \u0026lt; s.length(); i++) hash = (R * hash + s.charAt(i)) % M;  如果 R 比任何字符的值都大，这种计算相当于将字符串当作一个 N 位的 R 进制值，将它除以 M 并取余。\n1.4 组合键\n如果键的类型含有多个整型变量，我们可以和 String 类型一样将它们混合起来。例如，假设被查找的键的类型是 Date，其中含有几个整型的域： day（两个数字表示的日）， month（两个数字表示的月）和 year（4 个数字表示的年）。我们可以这样计算它的散列值:\nint hash = (((day * R + month) % M ) * R + year) % M;  只要 R 足够小不造成溢出，也可以得到一个 0 至 M-1 之间的散列值。\n1.5 将hashCode()返回值转化为一个数组索引\n由于每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个32 比特整数的 hashCode() 方法。每一种数据类型的 hashCode() 方法都必须和 equals() 方法一致。因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 hashCode()方法和除留余数法结合起来产生一个 0 到 M-1 的整数，方法如下：\n /** * 散列函数 * @param key 散列key * @return 索引值 */ private int hash(int key){ return (Integer.hashCode(key) \u0026amp; 0x7fffffff) % M; }  总的来说，一个优秀的散列函数应当满足以下三个要求：\n 一致性：等价的键必然产生相同的散列值。\n 高效性：计算简便，容易。\n 均匀性：均匀的散列所有的键。\n  2. 基于拉链法的散列表 在能将键转化为数组中的索引以后，我们就需要解决问索引冲突的问题，也叫碰撞处理。拉链法是上述解决散列索引冲突方法的其中一种，其原理是：将数组中的每一个元素指向一个链表，索引冲突的键都存储在一张链表中，链表中的每一个结点都存储了键以及其对应的值。\n此方法的局限性也在链表上，链表过长会严重影响查询和插入的性能。所以在确定数组的大小时，通常需要申请一个长度足够大的数组，使的所有的链表都尽可能的短从而保证查找的高效性。\nJava\n/** * 基于拉链法实现的散列表 */ public class SeparateChainingHashST { private int N; //键值对总数 private int M; //散列表大小(尽量使用素数) private Node[] st; /** * 用于存放键值对和下一个元素 */ private static class Node{ int key; //键 String val; //值 Node next; //下一个元素 Node(){}; Node(int key, String val, Node next){ this.key = key; this.val = val; this.next = next; } } public SeparateChainingHashST(){ this(97); } public SeparateChainingHashST(int M){ this.M = M; st = new Node[M]; for (int i = 0; i \u0026lt; M; i++) st[i] = new Node(); } public int size(){ return N; } /** * 散列函数 * @param key 散列key * @return 散列值 */ private int hash(int key){ return (Integer.hashCode(key) \u0026amp; 0x7fffffff) % M; } /** * 获取键值 * @param key 键 * @return 值val */ public String get(int key){ Node first = st[hash(key)]; for (Node x = first; x != null; x = x.next){ //存在key，返回val if (key == x.key) return x.val; } return null; } /** * 插入键值对 * @param key 键 * @param val 值 */ public void put(int key, String val){ Node first = st[hash(key)]; for (Node x = first; x != null; x = x.next){ //存在key，替换val if (key == x.key) { x.val = val; return; } } //不存在key，插入链表头 st[hash(key)] = new Node(key, val, first); N++; } }  实现中使用静态内部类Node作为每一个结点元素的类型，每一次put()插入操作如果发送了索引冲突都会将新的元素插入到索引位置链表的表头，变成首元素。\n查找元素分为两步：\n 根据键的散列值查找到对应的链表；\n 沿着链表顺序查找到键对应的元素。\n  当你能够预知所需要的符号表的大小时，这段短小精悍的方案能够得到不错的性能。目标是选择适当的数组大小 M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n3. 基于线性探测法的散列表 除了拉链法，另一种类型的方法是用大小为 M 的数组保存 N 个键值对，其中 M\u0026gt;N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为开放地址散列表。\n开放地址类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。开放地址散列表中最简单的方法叫做线性探测法：当发送索引冲突使，我们直接检查散列表中的下一个位置（将索引值加 1）。\n线性探测法插入键值对的流程：用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（将索引增大，到达数组结尾时折回数组的开头），直到找到该键替换value或者遇到一个空位置插入元素。基于线性探测法的散列表完整实现如下：\nJava\n/** * 基于线性探测法实现的散列表 */ public class LinearProbingHashST { private int N; // 符号表中键值对总数 private int M = 16; // 线性探测表的大小 private int[] keys; // 键 private String[] vals; // 值 public LinearProbingHashST(){ keys = new int[M]; vals = new String[M]; } private LinearProbingHashST(int M){ this.M = M; keys = new int[M]; vals = new String[M]; } public int size(){ return N; } /** * 散列函数 * @param key 散列key * @return 散列值 */ private int hash(int key){ return (Integer.hashCode(key) \u0026amp; 0x7fffffff) % M; } /** * 调整链表长度 * @param cap 新的长度 */ private void resize(int cap){ LinearProbingHashST lst = new LinearProbingHashST(cap); for (int i = 0; i \u0026lt; M; i++){ if (keys[i] != 0) lst.put(keys[i], vals[i]); } this.keys = lst.keys; this.vals = lst.vals; this.M = lst.M; } /** * 存入键值对 * @param key 键 * @param val 值 */ public void put(int key, String val){ if (N \u0026gt;= M/2) resize(2*M); int i; for (i = hash(key); keys[i] != 0; i = (i + 1) % M){ if (keys[i] == key){ vals[i] = val; return; } } keys[i] = key; vals[i] = val; N++; } /** * 获取键对应的值 * @param key 键 * @return 值 val */ public String get(int key){ for (int i = hash(key); keys[i] != 0; i = (i + 1) % M){ if (keys[i] == key){ return vals[i]; } } return null; } }  根据科研人员的大量科学研究：在散列函数能较为均匀的将键散布在区间[0, M-1]内的假设下。当散列表快满的时候查找所需的探测次数是巨大的：在全满时会一直探测进入无限循环。但是当使用率小于 1\u0026frasl;2 时，探测的预计次数只在 1.5到 2.5 之间。\n所以使用线性探测法实现散列表时，我们很有必要动态的调整数组的大小，使探测次数达到一个合理的值。上述实现中在每一次插入元素前判断散列表的利用率是否以及达到 1\u0026frasl;2 达到了将数组扩容为原来的2倍。使散列表的利用率一直小于 1\u0026frasl;2 从而确保探测次数的合理。\n动态调整数组的大小解决了很多问题，但是 resize() 方法每执行一次是会消耗大量资源的，特是在数组长度较长以后。因为每一执行次 resize() 都会在新数组长度下将所有以前的键值对重新插入。由于可以认为 hash() 是常数级别的操作，所以 resize() 的时间复杂度大约为线性级别。 幸运的是数组越大，需要调整的情况更少。\n4. 散列表的优缺点分析 各种符号表实现性能的比较如下表：\n   算法（数据结构） 查找(最坏) 插入(最坏) 查找命中(平均) 插入(平均) 内存使用（字节）     顺序查询（无序链表） N N N/2 N 48N   二分查找（有序数组） lgN N lgN N/2 16N   二叉树查找（二叉查找树） N N 1.39lgN 1.39lgN 64N   2-3 树查找（红黑树） 2lgN 2lgN 1.00lgN 1.00lgN 64N   拉链法 （链表数组） \u0026lt;lgN \u0026lt;lgN N/(2M) N/M 48N+32M   线性探测法（并行数组） clgN clgN \u0026lt;1.5 \u0026lt;2.5 [32N, 128N]    基于上表以及上文分析得到以下结论。\n优点：\n 理论上散列表能够支持和数组大小无关的常数级别的查找和插入操作（在所有符号表实现中最优）。  缺点：\n 每一种数据类型的键都需要一个优秀的散列函数，散列函数的好坏很大程度决定算法性能。\n 散列函数的计算可能复杂而且昂贵。\n 难以支持有序性相关的符号表操作。\n  "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/mybatis%E6%98%A0%E5%B0%84%E5%99%A83/",
	"title": "4. Mybatis映射器3",
	"tags": [],
	"description": "",
	"content": " 关于 Mybatis 映射器文件的知识点还差一个标签元素，是Mybatis 中最强大的元素，它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。resultMap的作用就是提供一系列，指定数据库列名与 javaBean 属性名映射关系的方法。涉及的知识点较多，需要用一整篇博客去记录它。\n1. 隐式结果映射(自动映射) 实际上，如果你用 mybatis 开发过小型的项目，你可能没有显示的用到 元素，但是你很有可能隐式的用了它。这正是ResultMap的设计思想，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。就像下面这个例子：\n javaBean:\npackage com.example.model; public class User { private int uid; private String username; private String password;   你只需要在映射器文件中写下如下\u0026lt;select\u0026gt;元素，然后使用你就可以获得一个内涵 User 对象的 List 集合。(前提是数据库列名能与 javaBean 属性一 一对应)\n \u0026lt;select\u0026gt;标签元素内容\n\u0026lt;select id=\u0026quot;selectUsers\u0026quot; resultType=\u0026quot;com.example.model.User\u0026quot;\u0026gt; select uid, username, password from user where id = #{id} \u0026lt;/select\u0026gt;   在这个获取User对象List集合的过程中，Mybatis 会幕后的创建一个 ResultMap 类对象，在根据属性名将是数据列映射到 javaBean 的属性上。如果列名和属性名不能一 一对应，可以在 SELECT 语句中对列使用别名，亦可以使列于属性相匹配，比如：\n 为列名增加别名的 SQL 语句\nselect u_id as \u0026quot;uid\u0026quot;, user_name as \u0026quot;username\u0026quot; , password from user   2. 高级结果映射 上面这种情况在 SQL 语句不是很复杂时可以使工作效率大大提高，但是在有时候在开发大型项目时，数据库内数据间的关系可能非常复杂。查询的 SQL 语句就会变得异常复杂。不过有了 ResultMap 就可以很轻松的描述列名与属性名之间的映射关系。\n 标签元素有两个重要的属性如下：\n id 当前命名空间中的一个唯一标识，用于标识一个\\。 type 被映射的 javaBean 类的完全限定名, 或者一个类型别名。   标签元素的子标签如下所示。\n constructor - 用于在实例化类时，注入结果到构造方法中  idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果  id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂类型的关联；许多结果将包装成这种类型  嵌套结果映射 – 关联本身可以是一个 resultMap 元素，或者从别处引用一个  collection – 一个复杂类型的集合  嵌套结果映射 – 集合本身可以是一个 resultMap 元素，或者从别处引用一个  discriminator – 使用结果值来决定使用哪个 resultMap  case – 基于某些值的结果映射，嵌套结果映射 – case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个   2.1  \u0026amp;  \u0026lt;id property=\u0026quot;uid\u0026quot; column=\u0026quot;u_id\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;username\u0026quot; column=\u0026quot;user_name\u0026quot;/\u0026gt;  这是结果映射最基本的内容，id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。两者之间的唯一不同是，id 元素表示的结果将是对象的标识属性，这会在比较对象实例时用到。指定 id 可以提高整体性能。\n两个元素都有一些重要的属性：\n   属性 描述     property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。   column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。   javaType 一个 Java 类的完全限定名，或一个类型别名。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。    2.2  元素 在有些情况下你想使用不可变类。 比如很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。 构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。 元素就是为此而生的。其形式类似于resultMap,例如：\n具有构造方法的 user 类：\npublic class User { //... public User(Integer id, String username, int age) { //... } //... }  按下面  标签元素的书写，即可将查询结果注入 User 的构造函数：\nconstructor 元素：\n\u0026lt;constructor\u0026gt; \u0026lt;idArg column=\u0026quot;id\u0026quot; javaType=\u0026quot;int\u0026quot; name=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;arg column=\u0026quot;age\u0026quot; javaType=\u0026quot;_int\u0026quot; name=\u0026quot;age\u0026quot; /\u0026gt; \u0026lt;arg column=\u0026quot;username\u0026quot; javaType=\u0026quot;String\u0026quot; name=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;/constructor\u0026gt;  从版本Mybatis 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。如上所示，第二和第三个形参的顺序与 constructor 元素中参数声明的顺序不匹配。但可以指定 name 属性值为参数名，即可与 javaType 属性一起来定位到该形参，而不用一定按构造方法形参顺序来编写 constructor 元素。\n\r2.3 关联元素 \u0026lt;association\u0026gt; 关联元素是用来处理“ 有一个 ”的问题，就是一个类其中包含了一个类类型的属性。例如一本书有一个封面，\u0026lt;association \u0026gt; 关联元素就是可以专门用来从结果中提取封面的数据，构造封面对象。其形式类似于resultMap，例如：\n \u0026lt;association property=\u0026quot;cover\u0026quot; column=\u0026quot;book_cover_id\u0026quot; javaType=\u0026quot;Cover\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;cover_id\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;bookName\u0026quot; column=\u0026quot;book_name\u0026quot;/\u0026gt; \u0026lt;/association\u0026gt;  其主要属性和描述：\n   属性 描述     property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。   javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。   column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=“{prop1=col1,prop2=col2}” 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。   select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=“{prop1=col1,prop2=col2}” 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。   resultMap 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。   columnPrefix 当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。   notNullColumn 默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。    利用提取数据注入到类中主要有两个方法，分别是： + 1.关联嵌套 Select 查询 + 2.关联嵌套结果映射\n关联嵌套 Select 查询的例子：\n\u0026lt;resultMap id=\u0026quot;bookResult\u0026quot; type=\u0026quot;Book\u0026quot;\u0026gt; \u0026lt;association property=\u0026quot;cover\u0026quot; column=\u0026quot;cover_id\u0026quot; javaType=\u0026quot;Cover\u0026quot; select=\u0026quot;selectCover\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;selectBook\u0026quot; resultMap=\u0026quot;bookResult\u0026quot;\u0026gt; SELECT * FROM book WHERE ID = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026quot;selectCover\u0026quot; resultType=\u0026quot;Cover\u0026quot;\u0026gt; SELECT * FROM cover WHERE ID = #{id} \u0026lt;/select\u0026gt;  可以看到关联嵌套 Select 查询需要有多个 Select 查询语句，一条语句负责查询包含其他类属性的类的数据（如例子中的 Book 类的查询语句：id=selectBook），其余语句用于查询类类型的属性的数据（如例子中的 Cover 类的查询语句：id=selectCover）。在id为bookResult的中的元素为查询书封面的查询语句提供了查询参数：cover_id。然后数据就会非常智能的注入到我们指定的类对象中。\n关联嵌套 Select 查询在编写SQL语句时是非常简单的，但是在运行效果上不是很理想。因为在执行查询时会执行很多的查询语句，特别是在处理大型数据表时。如果一个类具有 N 个类类型的属性，那么就需要执行 N+1 条查询语句，这显然不是科学合理的。所以这种方式更适用于处理较少的数据。\n\r为避免在处理大型数据表时执行过多的查询语句，Mybatis 提供了“关联嵌套结果映射”来处理关联映射问题。例子如下。\n查询语句：\n\u0026lt;select id=\u0026quot;selectBook\u0026quot; resultMap=\u0026quot;bookResult\u0026quot;\u0026gt; select B.id as book_id, B.title as book_title, B.cover_id as book_cover_id, C.id as cover_id, C.img_path as cover_img_path, from book B left outer join cover C on B.cover_id = C.id where B.id = #{id} \u0026lt;/select\u0026gt;  resultMap:\n\u0026lt;resultMap id=\u0026quot;bookResult\u0026quot; type=\u0026quot;Book\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;book_id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;title\u0026quot; column=\u0026quot;book_title\u0026quot;/\u0026gt; \u0026lt;association property=\u0026quot;cover\u0026quot; javaType=\u0026quot;Cover\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;cover_id\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;coverImgPath\u0026quot; column=\u0026quot;cover_img_path\u0026quot;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;  可以看到上面查询的 select 语句会更复杂一点，但是其查询时的性能会比第一种方法好很多。在有些时候我们在其他地方可能也用到了 Cover，而我们在前面也说过，\u0026lt;association\u0026gt; 元素就类似于一个\u0026lt;resultMap\u0026gt;。我们可以将cover的关联关系抽取出来，用一个resultMap表示。如下：\n\u0026lt;resultMap id=\u0026quot;bookResult\u0026quot; type=\u0026quot;Book\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;book_id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;title\u0026quot; column=\u0026quot;book_title\u0026quot;/\u0026gt; \u0026lt;association property=\u0026quot;cover\u0026quot; column=\u0026quot;book_cover_id\u0026quot; javaType=\u0026quot;Cover\u0026quot; resultMap=\u0026quot;coverResult\u0026quot;\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026quot;coverResult\u0026quot; type=\u0026quot;Cover\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;cover_id\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;coverImgPath\u0026quot; column=\u0026quot;cover_img_path\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  用\u0026lt;association\u0026gt;标签的resultMap属性指定一个结果映射来注入数据值。这样写在以后需要用到 Cover 的结果映射时直接用就可以了，比如在单独查询封面的时候。\n\u0026lt;collection\u0026gt; 集合元素 \u0026lt;association\u0026gt;关联元素是用来处理“有一个”的问题，而\u0026lt;collection\u0026gt;集合元素是用来处理“有多个”的问题，比如一本书可能有多个作者。\u0026lt;collection\u0026gt;集合元素与\u0026lt;association\u0026gt;关联元素是非常相似的，只有一些小细节地方的不同。集合元素也可以使用嵌套 Select 查询和基于连接的嵌套结果的映射集合。\n集合嵌套 Select 查询的例子：\n\u0026lt;resultMap id=\u0026quot;bookResult\u0026quot; type=\u0026quot;book\u0026quot;\u0026gt; \u0026lt;collection property=\u0026quot;authors\u0026quot; javaType=\u0026quot;ArrayList\u0026quot; column=\u0026quot;id\u0026quot; ofType=\u0026quot;Author\u0026quot; select=\u0026quot;selectAuthorsForbook\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;selectBook\u0026quot; resultMap=\u0026quot;bookResult\u0026quot;\u0026gt; SELECT * FROM book WHERE ID = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026quot;selectAuthorsForbook\u0026quot; resultType=\u0026quot;Author\u0026quot;\u0026gt; SELECT * FROM author WHERE book_ID = #{id} \u0026lt;/select\u0026gt;  其中ofType用于指定结果集合中对象的类型，在例子中的语义就是指定在List集合中装的是Author 类的对象。\n集合嵌套结果映射的例子：\n\u0026lt;select id=\u0026quot;selectBook\u0026quot; resultMap=\u0026quot;bookResult\u0026quot;\u0026gt; select B.id as book_id, B.title as book_title, B.author_id as book_author_id, A.id as author_id, A.name as author_name, from book B left outer join author A on B.id = A.book_id where B.id = #{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026quot;bookResult\u0026quot; type=\u0026quot;book\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;book_id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;title\u0026quot; column=\u0026quot;book_title\u0026quot;/\u0026gt; \u0026lt;collection property=\u0026quot;authors\u0026quot; ofType=\u0026quot;Author\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;author_id\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;author_name\u0026quot;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt;  由于Mybatis在一般情况下能够自己推断集合的类型，所以 javaType 属性可以不用写。\n 鉴别器元素 有时候数据表的一个字段可能会有几个值代表不同的涵义，最常见的是性别。在数据表中可能是用0，1表示。当查询时可能会需要根据性别做不同的操作。就像java中的switch语句，例如：\n\u0026lt;resultMap id=\u0026quot;peopleResult\u0026quot; type=\u0026quot;People\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;age\u0026quot; column=\u0026quot;age\u0026quot;/\u0026gt; \u0026lt;discriminator javaType=\u0026quot;int\u0026quot; column=\u0026quot;gender\u0026quot;\u0026gt; \u0026lt;case value=\u0026quot;0\u0026quot; resultMap=\u0026quot;manResult\u0026quot;/\u0026gt; \u0026lt;case value=\u0026quot;1\u0026quot; resultMap=\u0026quot;womanckResult\u0026quot;/\u0026gt; \u0026lt;/discriminator\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026quot;manResult\u0026quot; type=\u0026quot;Man\u0026quot; extends=\u0026quot;peopleResult\u0026quot;\u0026gt; \u0026lt;result property=\u0026quot;wife\u0026quot; column=\u0026quot;wife\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026quot;womanResult\u0026quot; type=\u0026quot;Woman\u0026quot; extends=\u0026quot;peopleResult\u0026quot;\u0026gt; \u0026lt;result property=\u0026quot;husband\u0026quot; column=\u0026quot;husband\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt;  "
},
{
	"uri": "https://compass-ak.gitee.io/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": " Python notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/springmvc/",
	"title": "SpringMVC",
	"tags": [],
	"description": "",
	"content": " Chapter 3.4 SpringMVC Notes "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/web%E5%BA%94%E7%94%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%E7%9A%84%E6%98%A0%E5%B0%84web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/",
	"title": "4. web应用和虚拟目录的映射（web应用部署）",
	"tags": [],
	"description": "",
	"content": "## []()web应用和虚拟目录（对外访问目录）的映射（Tomcat）\n当我们开发好一个web应用，想要供外界访问，就必须交给 web服务器来管理 web应用。当然要 web服务器知道这个 web应用就必须按照其要求的方法来部署web应用。首先在开发过程中最常用的是，直接将web应用放在webapps目录下，web服务器会将web应用的文件目录自动映射到虚拟目录（在浏览器地址栏访问web应用的目录，这个过程就叫虚拟目录的映射）。外界直接就可以访问web应用。\n但是在实际部署web应用可能会将web应用和web服务器分开存放，部署web应用不能直接放在webapps目录下就需要用以下2种方法来部署web应用：\n1.在conf目录下的 server.xml中配置部署\n首先需要在server.xml文件的 \u0026lt;host\u0026gt; 标签下创建一个 \u0026lt;Context /\u0026gt; 标签\n\u0026lt;Context path='虚拟目录' docBase='web应用实际目录'/\u0026gt;  ！修改 \u0026lt;host\u0026gt; 标签中我appBase属性可以更改web应用的默认目录，默认当然就是webapps。\n设置好保存后web服务器就可以用虚拟目录访问其对应的web应用。\n但是，由于修改了 server.xml 文件需要重启web服务器才会有效果。\n2.在 conf\\Catalina\\localhost 目录中配置\n在此目录中配置的规则是需要创建一个 .xml 文件，文件的名称就是虚拟目录的名称，其他的配置语法与上述 server.xml 中的配置语法相同，区别就是不用设置 path 属性\n比如我们在此目录下新建一个 a.xml 文件然后在文件内写入：\n\u0026lt;Context docBase='web应用实际目录'/\u0026gt;  保存后在浏览器地址栏输入：http://localhost:8080/a/1.html 就可以访问到对应web应用里面 1.html 页面内容了。\n如果想要设置多级虚拟目录，只需要在给 .xml 文件命名时用 # 将父目录和子目录隔开就可实现多级虚拟目录。\n而且这种方法与前一种相比，这种方法创建的虚拟映射目录是实时的，也就是说不用重启服务器（和放在webapps里面效果一样）。\n~~最后一小点\n才配好Tomcat没有更改其它配置的话直接访问 ：http://localhost:8080/ 会问到Tomcat的默认web应用的页面（Tomcat 首页），我们怎样才可以修改默认的web应用呢？答案是直接在此目录中创建一个 .xml 文件配置好作为默认 web应用。然后将文件名命名为：ROOT 就成功了。（在server.xml 文件 \u0026lt;host\u0026gt; 标签中创建一个没有设置path属性的 \u0026lt;Context /\u0026gt; 也可以指定默认的web应用）\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/mybatis/mybatis%E5%8A%A8%E6%80%81sql/",
	"title": "5. Mybatis动态sql",
	"tags": [],
	"description": "",
	"content": " MyBatis 的强大特性之一便是它的动态 SQL。简化了许多我们原本需要在JDBC编程中的一些操作，动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。Mybatis动态SQL需要用到的标签元素有：\n if choose (when, otherwise) trim (where, set) foreach  1. if 元素 例子：\n\u0026lt;select id=\u0026quot;selectAllOrderByTotal\u0026quot; resultType=\u0026quot;bean.Student\u0026quot; parameterType=\u0026quot;bean.StudentExample\u0026quot;\u0026gt; select st.*,sc.javaee,sc.android,sc.s_sql,sc.total from student st,score sc where st.snum=sc.snum \u0026lt;if test=\u0026quot;asc\u0026quot;\u0026gt; order by sc.total asc \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;!asc\u0026quot;\u0026gt; order by sc.total desc \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt;  在动态SQL中通常需要做的事情就是为查询添加约束条件，像上面的\u0026lt;select\u0026gt;元素就可以根据参数StudentExample 的 asc 属性的真假来判断是使用学生总分升序查询，还是学生总分降序查询。其中\u0026lt;if\u0026gt; 标签的 test 属性指定一个本判断的布尔表达式，实际效果与java或其他语言的if语句类似。相当于 test 指定if括号内的判断条件。\n在使用多个并列\u0026lt;if\u0026gt;判断标签，且其包含的处理语句逻辑互斥时（比如上面的升序，降序的查询处理），需要注意的是一定要保证 test判断条件时互斥的。不然最后执行的SQL语句可能会产生逻辑错误。\n2. choose, when, otherwise 元素 有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。上面的例子1.最好的实现方式就是用choose, when, otherwise 元素来实现，例子如下：\n\u0026lt;select id=\u0026quot;selectAllOrderByTotal\u0026quot; resultType=\u0026quot;bean.Student\u0026quot; parameterType=\u0026quot;bean.StudentExample\u0026quot;\u0026gt; select st.*,sc.javaee,sc.android,sc.s_sql,sc.total from student st,score sc where st.snum=sc.snum \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026quot;asc\u0026quot;\u0026gt; order by sc.total asc \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026quot;!asc\u0026quot;\u0026gt; order by sc.total desc \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; order by sc.total asc \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/select\u0026gt;  上面的例子重新实现了例子1.的语句的功能。但是添加了一点，在所有条件都不匹配时使用总分升序查询。也就是默认使用总分升序查询。需要说明的一点是 \u0026lt;when\u0026gt; 标签元素于\u0026lt;if\u0026gt; 类似由test 属性指定判断条件。\n3. trim, where, set 元素 1.trim trim是一个格式化SQL语句的标签元素，主要用于拼接sql的条件语句（前缀或后缀的添加或删除），可以完成set或者是where标记的功能。其主要属性如下：\n   属性 描述     prefix 指定需要添加的标签内 sql语句的前缀   suffix 指定需要添加的标签内 sql语句的后缀   prefixOverrides 指定需要去除的标签内 sql 语句前缀的关键字或者字符   suffixOverrides 指定需要去除的标签内 sql 语句后缀的关键字或者字符    例子：\n\u0026lt;update id=\u0026quot;updateByPrimaryKey\u0026quot; parameterType=\u0026quot;bean.StudentExample\u0026quot;\u0026gt; update student set \u0026lt;trim suffixOverrides=\u0026quot;,\u0026quot; \u0026gt; \u0026lt;if test=\u0026quot;name != null \u0026quot;\u0026gt; name=#{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;android != null \u0026quot;\u0026gt; android=#{android} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; where id=#{id} \u0026lt;/update\u0026gt;  在例子中看似不需要 \u0026lt;trim\u0026gt; 元素也可以很好的运行，其实不然。如果在第一条if条件为true而第二条if条件为false时，set属性结尾会有一个,。这显然是不符合 SQL 语句书写规范的，可能会出现一些奇怪的错误。用\u0026lt;trim\u0026gt;后,如果set属性z最后一个字符为,就会被去掉。我们编写SQL就会更加的方便。\n1.where where元素是用来解决多个查询约束组合的问题。有时候我们将 where 写在\u0026lt;if\u0026gt;等标签的外面，然后查询是若是一个条件都没有匹配，就可能会出现只有 where 没有条件的问题。要是写在标签元素内部，有可能会匹配到多个 where 。当然办法总比困难多，我们可以先在外部标签写一个 where 1=1，这样就不会出错了。但是这不是最好的办法，因为它执行了一次毫无意义的判断。mybatis 提供的\u0026lt;where\u0026gt;标签就可以完美的解决这些问题，简化写SQL语句的流程。\n例子：\n\u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt; SELECT * FROM BLOG \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;state != null\u0026quot;\u0026gt; state = #{state} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt; AND title like #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt; AND author_name like #{author.name} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  例子中，如果 \u0026lt;where\u0026gt; 标签下的SQL第一个字符串不是SQL关键字 mybatis 会为其添加一个 WHERE， 如果标签下的SQL第一个字符串是 AND或OR mybatis会将其替换为 WHERE。可以发现的是\u0026lt;where\u0026gt;标签的功能也可以用 \u0026lt;trim\u0026gt; 来实现。\n3. set set 元素的功能和 where 类似，只是用在设置语句属性值上。\n例子：\n\u0026lt;update id=\u0026quot;updateAuthorIfNecessary\u0026quot;\u0026gt; update Author \u0026lt;set\u0026gt; \u0026lt;if test=\u0026quot;username != null\u0026quot;\u0026gt;username=#{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;password != null\u0026quot;\u0026gt;password=#{password},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;email != null\u0026quot;\u0026gt;email=#{email},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;bio != null\u0026quot;\u0026gt;bio=#{bio}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt;  例子中，set 元素会动态前置 SET 关键字，同时也会删掉不合理的逗号。当然功能也可以用trim 标签元素实现。\n3. foreach 元素 动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。这就需要用到\u0026lt;foreach\u0026gt; 元素。\n例子：\n\u0026lt;select id=\u0026quot;selectStudnetByList\u0026quot; resultType=\u0026quot;bean.Student\u0026quot; parameterType=\u0026quot;bean.StudentExample.list\u0026quot;\u0026gt; select st.*,sc.javaee,sc.android,sc.s_sql,sc.total from student st,score sc where st.snum=sc.snum AND id IN \u0026lt;foreach item=\u0026quot;id\u0026quot; index=\u0026quot;index\u0026quot; collection=\u0026quot;list\u0026quot; open=\u0026quot;(\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;)\u0026quot;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt;  例子实现的SQL语句功能是根据指定的 id 集合查询 student 表，其中 foreach 的item参数指定集合item的变量名，index指定 item 索引位置的变量名，collection指定集合，open指定其实字符串，close指定结尾字符串，separator指定每一项的分隔符。\n最后还值得一提是bind元素，bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文，\n例子：\n\u0026lt;select id=\u0026quot;selectStudentLikeName\u0026quot; resultType=\u0026quot;Student\u0026quot;\u0026gt; \u0026lt;bind name=\u0026quot;pattern\u0026quot; value=\u0026quot;'%' + _parameter.getName() + '%'\u0026quot; /\u0026gt; SELECT * FROM student WHERE name LIKE #{pattern} \u0026lt;/select\u0026gt;  "
},
{
	"uri": "https://compass-ak.gitee.io/resume/",
	"title": "Resume",
	"tags": [],
	"description": "",
	"content": " 瞿阿康 / Qu A Kang 个人信息  手机：18586643989\n Email：quakang@163.com\n QQ：1442904439\n 技术博客：https://compass-ak.gitee.io\n Github：https://github.com/compassak\n 期望职位：java开发实习生\n  教育经历  2017.09 - 2022.06 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 天津理工大学 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 软件工程 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 本科  我的技能  后端：熟悉 Java 语言; 熟悉 Spirng，SpringMVC，Mybatis 框架; 熟悉 mysql 数据库; 有良好debug的能力\n 前端：熟悉 Bootstrap 框架; 熟悉 jQuery，Ajax 的使用; 能快速使熟悉使用前端插件，如bootstrap-table等\n 工具：熟悉git版本控制工具，Maven项目管理工具，熟练使用IDEA\n 熟悉常用的数据结构和算法\n 略懂 Python 语言; 了解 SpringBoot，SpringCloud，Redis; 兴趣广泛，愿意学习新技术\n  项目经历 校园二手商品交易平台（用户聊天模块: https://github.com/compassak/Communi）\n 项目介绍：学生在校期间的许多物品是可以重复使用的，比如书本，座椅等。传统的线下跳蚤市场开放时间短，有碍学校管理。 我们开发的这个系统就是为了解决这个问题，让学生间的资源得到更好更有效的流转利用。\n 我的任务：完成用户聊天模块（WebSocket，图片），商品留言模块开发。\n 难点：查询一个用户的最近会话列表，sql语句冗长且查询效率低（产生原因：数据库设计缺陷）。\n 解决方法：以空间换时间，新增一张会话表帮助查询。\n  自我评价  有较强的自学能力，对新技术有浓厚的兴趣。做事认真负责，有较强的责任感。  "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84-%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/",
	"title": "5. web应用的组织结构 虚拟主机的配置",
	"tags": [],
	"description": "",
	"content": " ## []()web应用的组织结构 虚拟主机的配置\n[]()1.web 应用的组织结构 结构及各部分作用如下：\n这里主要介绍一下 web.xml 文件的作用。\n1.设置web应用的首页\n在标签 \u0026lt;web-app\u0026gt; 中的 \u0026lt;welcome-file-list\u0026gt; 标签中新建 \u0026lt;welcome-file\u0026gt; 标签，标签之间放置web应用的首页的名称。也可有多个 \u0026lt;welcome-file\u0026gt; 标签来设置多个备用的首页，优先级按 \u0026lt;welcome-file\u0026gt; 顺序编排。\n~~下面的功能作用后续完善。\n2.命名与定制URL。我们可以为Servlet和JSP文件命名并定制URL,其中定制URL是依赖命名的，命名必须在定制URL前。\n3.定制初始化参数：可以定制servlet、JSP、Context的初始化参数，然后可以再servlet、JSP、Context中获取这些参数值。\n4.指定错误处理页面，可以通过“异常类型”或“错误码”来指定错误处理页面。\n5.设置过滤器：比如设置一个编码过滤器，过滤所有资源\n6.设置监听器\n7.设置会话(Session)过期时间，其中时间以分钟为单位。\n[]()2.虚拟主机的配置（搭建网站） 1.什么是虚拟主机\n一台物理机上搭建多个web站点，每个web站点独立运行，互不干扰，这些站点就是\u0026rdquo;虚拟主机\u0026rdquo;。\nTomcat 配置虚拟主机需要编辑 Server.xml 文件， \u0026lt;Host\u0026gt; 元素表示一个虚拟主机，想要创建一个虚拟主机， \u0026lt;Host\u0026gt; 标签需放在 \u0026lt;Engine\u0026gt; 标签内，基本属性有，虚拟主机名：name，虚拟主机目录： appBase ，如下是一个配置例子。\n\u0026lt;Host name='XXXXXXXX' appBase=\u0026quot;XXXXXXXX\u0026quot; unpackWARs=\u0026quot;true\u0026quot; autoDeploy=\u0026quot;true\u0026quot; \u0026lt;/Host\u0026gt;  配置好后启动服务器，若想要用浏览器通过虚拟主机名访问，虚拟主机内的资源。需要在DNS服务器上有此虚拟主机名对应的主机 IP 地址，这就需要去购买域名。\n我们可以更改主机 hosts 文件，体验一下效果。在 hosts 文件中最后加一行，前一部分写主机 ip 后一部分写我们的虚拟主机名，保存后即可在本机的浏览器上访问到虚拟主机名的地址。示例如下：\n#my_hosts Start 127.0.0.1 XXXXXXXXXX  #号是注释\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/tomcat%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB%E9%85%8D%E7%BD%AEhttps%E8%BF%9E%E6%8E%A5%E5%99%A8/",
	"title": "6. Tomcat结构体系&amp;配置https连接器",
	"tags": [],
	"description": "",
	"content": "## []()Tomcat结构体系\u0026amp;配置https连接器\n1.Tomcat结构体系如下图\n2.配置https连接器\n1.生成密钥库是用 keytool 工具，java JDK 内置了keytool工具，如果安装了java jdk环境，就可以直接在 cmd 使用keytool。\n2.用 keytool -genkeypair -keyalg RSA -keystore \u0026quot;test.keystore\u0026quot; 生成密钥库。（生成密钥库的位置在操作系统的用户目录下），各命令含义可用 keytool --help 查询，详细学习操作可参考这位作者写的博客。 （孤傲苍狼：https://www.cnblogs.com/xdp-gacl/p/3750965.html）\n输入代码回车后，需要设置密钥库口令（相当于密钥库的密码），下面你回答问题的答案信息用于生成密钥库。\n3.将keystore文件放在 conf 文件夹内，然后再 server.xml 文件用 \u0026lt;Connector\u0026gt; 元素配置连接器，代码如下：\n\u0026lt;Connector port=\u0026quot;8443\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; SSLEnabled=\u0026quot;ture\u0026quot; maxThreads=\u0026quot;150\u0026quot; scheme=\u0026quot;https\u0026quot; secure=\u0026quot;true\u0026quot; clientAuth=\u0026quot;false\u0026quot; sslProtocol=\u0026quot;TLS\u0026quot; keystoreFile=\u0026quot;conf/test.keystore\u0026quot; keystorePass=\u0026quot;2438675\u0026quot;/\u0026gt;  主要属性–\u0026gt;keystoreFile ：指定密钥库，keystorePass：密钥库口令\n保存重启Tomcat 访问 https://localhost:8443/ 可验证。\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/http%E8%AF%B7%E6%B1%82%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/",
	"title": "7. HTTP请求&amp;请求方式",
	"tags": [],
	"description": "",
	"content": "## []()HTTP请求\u0026amp;请求方式\n1.请求的结构如下\n2.请求方式\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/http%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4/",
	"title": "8. HTTP常用请求头",
	"tags": [],
	"description": "",
	"content": " 1.请求头及其说明    请求头 说明 例子     Accept 用于告诉服务器，浏览器支持的MIME类型 /：支持任何数据类型   Accept-Charset 用于告诉服务器，浏览器可接受的字符集 GB18030，Unicode   Accept-Encoding 用于告诉服务器，浏览器支持的数据压缩格式 gzip ，deflate   Accept-Language 用于告诉服务器，浏览器的语言环境    Host 用于告诉服务器，浏览器想访问的主机名，端口    if-Modified-Since 用于告诉服务器，浏览器缓存该资源的时间    Referer 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面    User-Agent 用于告诉服务器，浏览器的类型    Cookie 这是最重要的请求头信息之一（以后详写）    Connection 表示是否需要持久连接 Keep-Alive   Date 当前时间    Range 请求资源的部分内容(不包括响应头的大小)     "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/http%E5%93%8D%E5%BA%94%E5%B8%B8%E7%94%A8%E5%93%8D%E5%BA%94%E5%A4%B4/",
	"title": "9. HTTP响应&amp;常用响应头",
	"tags": [],
	"description": "",
	"content": "## []()HTTP响应\u0026amp;常用响应头\n1.响应的结构\n2.响应的状态\n3常用响应头\n 响应头 | 说明 | 例子 ------------------- | ----------------------------------------- | --------------------------- Content-Encoding | 内容的压缩编码格式 | GZIP，deflate Content-Length | 表示内容长度。 | Content-Type | 表示后面的文档属于什么MIME类型。 | text/h323，application/x-001 content-Disposition | 告诉浏览器以下载的方式打开数据 | attachment Date | 当前的GMT时间。 | Expires | 告诉浏览器缓存该资源多长时间，0或-1则是不用缓存。 | Last-Modified | 文档的最后改动时间 | Location | 表示客户应当到哪里去提取文档。 | Refresh | 表示浏览器应该在多少时间之后刷新文档。 | Server | 服务器名字。 | Set-Cookie | 设置和页面关联的Cookie。 | Transfer-Encoding | 告诉浏览器数据的传输格式 | chunked,identity Etag | 对象资源的标记值（一般是资源对象的哈希值），服务器用来判断浏览器缓存的资源是否过期 |  "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8eclipse%E5%BC%80%E5%8F%91servlet/",
	"title": "10. servlet开发入门&amp;Eclipse开发Servlet",
	"tags": [],
	"description": "",
	"content": "## []()servlet开发入门\u0026amp;Eclipse开发Servlet\n1.servlet简介\nJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\n2.Servlet运行过程\n3.Eclipse开发Servlet\n提示！开发web应用需要用Eclipse for J2EE IDE ,安装参考此博客：https://www.cnblogs.com/shootercheng/p/6286213.html\n有关Servlet3.0的特性和与2.0的区别参考这篇博客：https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html\n首先我们要关联Eclipse与Tomcat，打开Eclipse点击 window\u0026gt;\u0026gt;preferences\u0026gt;\u0026gt;server\u0026gt;\u0026gt;Runtime\u0026gt;\u0026gt;environments\u0026gt;\u0026gt; 点击ADD增加 Tomcat 如下图：\n选择后，根据自己的Tomcat版本选择相应版本添加。\n添加之后就可以创建动态web工程了，如下图。\n点击下一步，重点来了！！，之前的博客里面有详写了web应用的结构，我们的的程序编译后的java程序是要放在classes目录下，然而用eclipse创建时会默认放在工程的build目录下，如下图。\n亲自跳坑，亲测有效，如果不更改此路径（output folder）程序运行后会将.class文件编译到build目录下，然后死活无法访问：( 404\n然后点击 finish 创建工程，工程的目录结构如下：\n然后我们写一个小程序来测试一下，用service方法来应答HTTP请求。具体代码如下：\npackage web; import java.io.*; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; @WebServlet(\u0026quot;/S1\u0026quot;) public class Servlet extends HttpServlet { private static final long serialVersionUID = 1L; public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { OutputStream out = response.getOutputStream(); out.write(\u0026quot;welcome to Servlet\u0026quot;.getBytes()); } }  里面的注释@WebServlet(\u0026ldquo;/S1\u0026rdquo;)设置了此程序对外访问的虚拟目录。\n保存后鼠标右击工程，选择 Run as \u0026gt;\u0026gt; Run on server 如下图。\n然后浏览器访问 http://localhost:8080+工程名+S1（也就是刚才注释设置的虚拟访问路径）就成功了。\n最后，如果已经创建了工程而又没有更改Java文件 output folder ，可以鼠标右键工程选择 build Path \u0026gt;\u0026gt; java build path \u0026gt;\u0026gt; source 就可以更改了。如下图\n~~\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet-%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/",
	"title": "11. Servlet 开发的一些细节",
	"tags": [],
	"description": "",
	"content": "## []()Servlet 开发的一些细节\n1.HTTPServlet类简介\n2. url 匹配 servlet 带*号的虚拟目录名的规则：（1）越相似的优先匹配（2） * 号在前面的优先级低于 * 号在后面的（下面是几个栗子）\n3. Servlet的运行\n4.一般情况下我们创建的Servlet都是会在web服务器启动后，用户第一次访问servlet时才会创建 servlet对象，哪我们怎么让servlet 在启动web服务器时启动呢，在Servlet 2.x 时会在 web.xml 里的 \u0026lt;load-on-startup\u0026gt; 元素来设置，而Servlet 3.0 在程序中的 @WebServlet（loadOnStartup=2） 的注释中就可以设置（与上述元素设置等价，数字大小决定优先级，从1开始越小优先级越高）\n！！！经过上面的学习会有可能为了方便而设置虚拟访问路径为（\u0026rdquo;/\u0026ldquo;）,就可以直接访问工程名是访问此时的Servlet，细心的人可能会发现此时工程内的静态web资源无法访问，去查看服务器conf目录下的web.xml文件会发现这样一段代码：\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;jsp\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.apache.jasper.servlet.JspServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;fork\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;xpoweredBy\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;3\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  一切都明白了，web服务器在启动时会构建一个优先级为1的 Servlet 对象，而且它的虚拟目录就是（\u0026rdquo;/\u0026ldquo;）,这个 Servlet对象就是用来处理用户访问服务器的静态web资源的servlet对象。我们为了图方便而设置的虚拟目录就屏蔽了这个Servlet对象，从而无法访问静态web资源。：）\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/",
	"title": "12. Servlet获取表单数据",
	"tags": [],
	"description": "",
	"content": "## []()Servlet获取表单数据\n很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。\n1.GET方法\nGET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。信息用？与url分隔\u0026amp;连接，如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。\n这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。\n2.POST方法\n另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。\n3.使用Servlet获取表单数据\nServlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：\ngetParameter()：您可以调用 request.getParameter() 方法来获取表单参数的值。 getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。 getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。  3.1 表单提交使用GET方法的实例\n使用 servlet 3.0 获得表单数据数据要主要注意以下2点。\n 1, form 表单的 Action 属性值的目录所指代的 Servlet 应包含工程目录，或直接写Servlet的虚拟映射目录，也就是说 Anction 属性值应为：/工程名/Servlet虚拟映射目录 或 Servlet虚拟映射目录 2，表单 value 值尽量不使用中文，传输后无法解析。 3.2 GET方法案例\n以下是一个获取使用GET方法表单数据的方法。在获取单选按钮，下拉菜单的数据时，只会根据 name 属性匹配 checked 为“true”的 value 值。而在获取复选框的数据时由于复选框之间没有太大联系，可取不同的 name 属性值来区分每一个复选框。\n1.html 文件代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Insert title here\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form name=\u0026quot;form1\u0026quot; method=\u0026quot;get\u0026quot; action=\u0026quot;GetRequest\u0026quot;\u0026gt; 姓名： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt;\u0026lt;br /\u0026gt; 学号： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;SID\u0026quot; /\u0026gt;\u0026lt;br /\u0026gt; 性别： \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;man\u0026quot; name=\u0026quot;sex\u0026quot;/\u0026gt;男 \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;woman\u0026quot; name=\u0026quot;sex\u0026quot;/\u0026gt;女 年龄：\u0026lt;select name=\u0026quot;age\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;17\u0026quot;\u0026gt;17\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026quot;18\u0026quot;\u0026gt;18\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026quot;19\u0026quot;\u0026gt;19\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026quot;20\u0026quot;\u0026gt;20\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot; size=20\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   GET方法Servlet 代码：\npackage getFormData; import java.io.IOException; import java.io.PrintWriter; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/GetRequest\u0026quot;) //虚拟映射目录 public class GetRequest extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out=response.getWriter(); //获响应取流对象 response.setContentType(\u0026quot;text/html\u0026quot;); //设置响应内容 out.print(\u0026quot; ALL information:\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;); Enumeration\u0026lt;String\u0026gt; parameterNames=request.getParameterNames(); //获取所有表单元素的name值 while(parameterNames.hasMoreElements()) { //遍历表单元素 String name=parameterNames.nextElement(); String[] values=request.getParameterValues(name); out.print(name+\u0026quot; : \u0026quot;+values[0]+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); } } }  html 页面：\n填好数据提交后结果：\n3.2 POST方法案例\n使用 GET 方法提交表单数据会使数据显示在URL中，若表单包含敏感信息则不是一个好的选择,而且get方法提交数据不能超过1024个字符。故提交表单数据经常用的是Post方法，以下是Post方法实例HTML文件代码的和上述相同，method方法更改为：post。\nPost方法Servlet代码如下：\npackage getFormData; import java.io.IOException; import java.io.PrintWriter; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/PostRequest\u0026quot;) public class PostRequest extends HttpServlet { private static final long serialVersionUID = 1L; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\u0026quot;text/html\u0026quot;); //设置响应内容 response.getWriter().print(\u0026quot; ALL information:\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;); Enumeration\u0026lt;String\u0026gt; parameterNames=request.getParameterNames(); //获取所有表单元素的name值 PrintWriter out=response.getWriter(); while(parameterNames.hasMoreElements()) { //遍历表单元素 String name=parameterNames.nextElement(); String[] values=request.getParameterValues(name); out.print(name+\u0026quot; : \u0026quot;+values[0]+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); } } }  填写表单提交结果：\n就在url上没有信息，会安全许多。\n最后附上一个获取页面表单所有信息的 Servlet代码：\npackage getFormData; import java.io.IOException; import java.io.PrintWriter; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/ALLRequest\u0026quot;) public class ALLForm extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\u0026quot;text/html\u0026quot;); // 设置响应内容 response.getWriter().print(\u0026quot; ALL information:\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;); Enumeration\u0026lt;String\u0026gt; parameterNames = request.getParameterNames(); // 获取所有表单元素的name值 PrintWriter out = response.getWriter(); while (parameterNames.hasMoreElements()) { // 遍历表单元素 String name = parameterNames.nextElement(); String[] values = request.getParameterValues(name); if (values.length == 1) { out.print(name + \u0026quot; : \u0026quot; + values[0] + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); } if (values.length \u0026gt; 1) { out.print(name + \u0026quot; : \u0026quot;); for (String value : values) { out.print(value + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); } } } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  ~~\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet-cookies%E5%A4%84%E7%90%86/",
	"title": "13. Servlet Cookies处理",
	"tags": [],
	"description": "",
	"content": "## []()Servlet Cookies处理\n1.Cookies 的主要用途\nCookies 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。\n2.Cookies 处理的一般流程\n(1). 用户在浏览器页面提交表单数据。\n(2). 服务器根据自己的业务需求，用某些用户的数据生成 cookie 。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上。\n(3). 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些Cookies 信息发送到服务器，服务器将使用这些信息来识别用户。\n3.Servlet 中和Cookies相关的方法\n 序号 | 方法 -- | -------------------------------------------------------------------------------------------------- 1 | public void setDomain(String pattern)该方法设置 cookie 适用的域。 2 | public String getDomain()该方法获取 cookie 适用的域，例如 w3cschool.cn。 3 | public void setMaxAge(int expiry)该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。 4 | public int getMaxAge()该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。 5 | public String getName()该方法返回 cookie 的名称。名称在创建后不能改变。 6 | public void setValue(String newValue)该方法设置与 cookie 关联的值。 7 | public String getValue()该方法获取与 cookie 关联的值。 8 | public void setPath(String uri)该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。 9 | public String getPath()该方法获取 cookie 适用的路径。 10 | public void setSecure(boolean flag)该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。 11 | public void setComment(String purpose)该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。 12 | public String getComment()该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。  4.实例\n（1）我们先用 landing.html 页面模拟用户提交数据。如下图：\nlanding.html 文件如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Insert title here\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form name=\u0026quot;form1\u0026quot; method=\u0026quot;post\u0026quot; action=\u0026quot;SetCookies\u0026quot;\u0026gt; UN： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;userName\u0026quot; /\u0026gt;\u0026lt;br /\u0026gt; PW： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;password\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot; size=20\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  （2）通过名为 SetCookies 的Servlet 来获取数据，并返回cookies 存储在用户计算机中。如下图：\nSetCookies .java文件如下：\npackage cookies; import java.io.IOException; import java.util.Enumeration; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; @WebServlet(\u0026quot;/SetCookies\u0026quot;) public class SetCookies extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\u0026quot;text/html\u0026quot;); // 设置响应内容 Enumeration\u0026lt;String\u0026gt; parameterNames = request.getParameterNames();// 获取所有表单元素的name值 while (parameterNames.hasMoreElements()) { // 遍历表单元素 String name = parameterNames.nextElement(); Cookie cookie=new Cookie(name,request.getParameterValues(name)[0]); //利用表单信息生成cookie cookie.setMaxAge(60*2); //设置cookie销毁时间（2 分钟） response.addCookie(cookie); //增加 cookie } response.getWriter().write(\u0026quot;cookies set successful\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  （3）最后用一个名为 ReadCookies 来读取cookies。如下图：\nReadCookies .java 文件如下：\npackage cookies; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/ReadCookies\u0026quot;) public class ReadCookies extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie[] cookies=null; cookies=request.getCookies(); for(int i=0;i\u0026lt;cookies.length;i++) { response.getWriter().write(\u0026quot;cookie_name : \u0026quot;+cookies[i].getName()+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;+ \u0026quot;cookie_value : \u0026quot;+cookies[i].getValue()+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  5.通过 Servlet 删除 Cookies\n删除 Cookies 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：\n（1）读取一个现有的 cookie，并把它存储在 Cookie 对象中。\n（2）使用 setMaxAge() 方法设置 cookie 的年龄为零，来删除现有的 cookie。\n（3）把这个 cookie 添加到响应头。\n由于较简单就不写实例了。\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet-session%E8%B7%9F%E8%B8%AA/",
	"title": "14. Servlet session跟踪",
	"tags": [],
	"description": "",
	"content": "## []()Servlet session跟踪\n1.什么是session\nSession 对象存储特定用户会话所需的属性及配置信息。\n一般情况下，session都是存储在服务器内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用， Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。\n2.Tomcat中session的工作原理\n（1） session 的产生，存放\n当浏览器访问服务器时，服务器使用HttpServletRequest的getSession(true)的取得浏览器cookies中的sessionid时，如果没有session对象，也就是浏览器第一次访问服务器，服务器就会生成一个session对象。tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；存储在服务器的内存中，tomcat的StandardManager类将session存储在内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。\n（2）session 作用\n当用户浏览器cookies中有sessionid的时候，服务器就可以从HttpServletRequest 类对象得到 sessionid，从而查找服务器中的session对象得到用户浏览器的session信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。\n3.Servlet中与session相关的方法\n 序号 | 方法 -- | ----------------------------------------------------------------------------------- 1 | public void setAttribute(String name,Object value)将value对象以name名称绑定到会话 2 | public object getAttribute(String name)取得name的属性值，如果属性不存在则返回null 3 | public void removeAttribute(String name)从会话中删除name属性，如果不存在不会执行，也不会抛处错误. 3 | public Enumeration getAttributeNames()返回和会话有关的枚举值 4 | public void invalidate()使会话失效，同时删除属性对象 5 | public Boolean isNew()用于检测当前客户是否为新的会话 6 | public long getCreationTime()返回会话创建时间 7 | public long getLastAccessedTime()返回在会话时间内web容器接收到客户最后发出的请求的时间 8 | public int getMaxInactiveInterval()返回在会话期间内客户请求的最长时间为秒 9 | public void setMaxInactiveInterval(int seconds)允许客户客户请求的最长时间 10 | ServletContext getServletContext()返回当前会话的上下文环境，ServletContext对象可以使Servlet与web容器进行通信 11 | public String getId()返回会话期间的识别号  4.实例\n这个实例模仿用户从第一访问，服务器为其设置session，到再次访问网站，服务器读取其session的过程。\npackage session; import java.io.IOException; import java.io.PrintWriter; import java.util.Date; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\u0026quot;/Session\u0026quot;) public class Session extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getSession(true); response.setContentType(\u0026quot;text/html\u0026quot;); // 设置页面响应格式 HttpSession session = request.getSession(true); // (获取 or 生成)session对象 Date CreateTime = new Date(session.getCreationTime()); // 获取session生成时间 Date lastAccessTime = new Date(session.getLastAccessedTime()); //获取用户最后一次访问服务器的时间。 //设置几个key，value用来测试 Integer visitCount = 1; String visitCounkey = \u0026quot;visitCount\u0026quot;; String userIDkey = \u0026quot;userID\u0026quot;; String userID = \u0026quot;qak\u0026quot;; String title = \u0026quot;Welcome Back\u0026quot;; if (session.isNew()) { //判断用户是否是第一次访问 title = \u0026quot;Welcome\u0026quot;; session.setAttribute(userIDkey, userID); session.setAttribute(visitCounkey, visitCount); } else { visitCount = (Integer) session.getAttribute(visitCounkey); visitCount += 1; session.setAttribute(visitCounkey, visitCount); } PrintWriter out = response.getWriter(); // 获得输出流对象 out.println(\u0026quot;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;meta charset=\\\u0026quot;UTF-8\\\u0026quot;\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;title\u0026gt;\u0026quot;+ title + \u0026quot;\u0026lt;/title\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;body\u0026gt;\\r\\n\u0026quot; + title+\u0026quot;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;+ \u0026quot;\u0026lt;b\u0026gt;\u0026quot;+\u0026quot;sessionid : \u0026quot; + session.getId() +\u0026quot;\u0026lt;b /\u0026gt;\u0026quot;+ \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;+ \u0026quot;CreateTime : \u0026quot; + CreateTime + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot; + \u0026quot;lastAccessTime : \u0026quot; + lastAccessTime + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot; + visitCounkey+ \u0026quot; : \u0026quot; + visitCount + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot; + userIDkey + \u0026quot; : \u0026quot; + userID + \u0026quot;\u0026lt;br /\u0026gt;\u0026quot; + \u0026quot;\u0026lt;/body\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); //session.invalidate(); //删除session对象。 } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  第一次访问结果：\n第二次访问结果：\n第八次访问结果：\n5.删除session\n当您完成了一个用户的 session 会话数据，您有以下几种选择：\n（1）移除一个特定的属性：您可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。\n（2）删除整个 session 会话：您可以调用 public void invalidate() 方法来丢弃整个 session 会话。\n（3）设置 session 会话过期时间：您可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。\n（4） 注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。\n（5）web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，标签中的时间以分钟为单位。\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servletcontext-%E5%AF%B9%E8%B1%A1/",
	"title": "15. ServletContext 对象",
	"tags": [],
	"description": "",
	"content": "## []()ServletContext 对象\n参考教程：https://www.w3cschool.cn/servlet/servlet-3ceg2p0t.html\n1.ServletContext 对象简介\nServletContext是一个全局的储存信息的空间，服务器开始就存在，服务器关闭才释放。为了方便大家理解，我们将ServletContext和Cookie、Session做一个简单对比，如下图：\n我们可以把ServletContext当成一个公用的空间，可以被所有的客户访问，如上图，A、B、C三个客户端都可以访问。\nWEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用，并且它被所有客户端共享。\n由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。\n当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁。\n2.使用ServletContext对象\n（1）怎么得到 ServletContext对象\nthis.getServletContext(); this.ServletConfig().getServletContext();  主要有以上两种方法来获取ServletContext对象。\n（2）使用ServletContext对象\n你可以把它想象成一张表，这个和Session非常相似：每一行就是一个属性\n和其对应的value值，可以用来存储信息。\n添加属性：setAttribute(String name, Object obj); 得到值：getAttribute(String name)，这个方法返回Object 删除属性：removeAttribute(String name)  3.实例\n这个实例演示，一个Servlet向ServletContext对象写入信息。另一个Servlet读取Servlet对象的信息。（Context1写入信息，Context2读取信息）\nContext1代码如下：\npackage context; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Context1\u0026quot;) public class Context1 extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); ServletContext context = this.getServletContext(); context.setAttribute(\u0026quot;name\u0026quot;, \u0026quot;qak\u0026quot;); context.setAttribute(\u0026quot;password\u0026quot;, \u0026quot;20174044\u0026quot;); out.println(\u0026quot;Context1-\u0026gt;Context Finished writing information!\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  访问结果：\nContext2 代码如下：\npackage context; import java.io.IOException; import java.io.PrintWriter; //import java.util.Enumeration; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Context2\u0026quot;) public class Context2 extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out=response.getWriter(); ServletContext context = this.getServletContext(); //Enumeration\u0026lt;String\u0026gt; info= context.getAttributeNames(); out.println(\u0026quot;Context_information: \u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;); out.println(\u0026quot;name : \u0026quot;+(String)context.getAttribute(\u0026quot;name\u0026quot;)+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;+ \u0026quot;password : \u0026quot;+(String)context.getAttribute(\u0026quot;password\u0026quot;)); //out.println(\u0026quot;All Context information: \u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;\u0026quot;); // 获取Context所有对象的属性和值 /* while(info.hasMoreElements()) { String key=info.nextElement(); out.println(key+\u0026quot; : \u0026quot;+context.getAttribute(key)+\u0026quot;\u0026lt;br /\u0026gt;\u0026quot;); }*/ } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  访问结果：\n4.ServletContext对象的应用\n1、多个Servlet可以通过ServletContext对象来实现数据间的共享\n类似于Session，通过ServletContext对象我们也可以实现数据共享，但值得注意的是，Session是只能在一个客户端中共享数据，而ServletContext中的数据是在所有客户端中都可以实现数据共享的。\n2、实现Servlet的请求转发\n之前我们学过的请求转发是通过request对象的：\nrequest.getRequestDispatcher(\u0026quot;/url\u0026quot;).forward(request, response);  这里要说明的是，ServletContext也可以实现请求转发：\nthis.getServletContext().getRequestDispatcher(\u0026quot;/url\u0026quot;).forward(request, response);  这两个转发效果是一样的。\n3、获取Web应用的初始化参数\n我们可以用标签为servlet配置初始化参数，然后使用ServletConfig对象获取这些参数，假如有如下的MyServlet，它的配置为：\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.gavin.servlet.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt;  可以看到它配置了一个初始化参数:encoding=utf-8，那么我们在MyServlet的源代码中需要这样去得到这个参数：\nString encoding = this.getServletConfig().getInitParameter(“encoding”);\n注意，上述的参数配置方法只针对一个特定的Servlet有效，我们可以通过ServletContext来获取全局的、整个Web应用的初始化参数，全局的初始化参数是这样配置在web.xml文件中的：\n\u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;name\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;gavin\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt;  然后我们可以在任意一个Servlet中使用ServletContext获取这个参数：\nString name = this.getServletContext().getInitParameter(“name”);\n在网站开发中，有很多功能要使用ServletContext，比如\n 网站计数器 网站的在线用户显示 简单的聊天系统\n总之，如果是涉及到不同用户共享数据，而这些数据量不大，同时又不希望写入数据库中，我们就可以考虑使用ServletContext实现。 ServletContext使用建议  因为存在ServletContext中的数据在服务器中会长时间，这样就会占用很多内存，因此在使用ServletContext时，建议不要往里面添加过大的数据！\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/",
	"title": "16. 日期时间处理",
	"tags": [],
	"description": "",
	"content": " ## []()日期时间处理\nServlet 最大的优势就是可以使用 Java 中的大多数可用的方法。处理时间也是非常的方便。处理时间一般是用Date类。首先介绍一下Date类的方法如下：\n1.Date方法\n 序号 | 方法 -- | ------------------------------------------------------------------------------------------------------------ 1 | boolean after(Date date)如果调用的 Date 对象中包含的日期在 date 指定的日期之后，则返回 true，否则返回 false。 2 | boolean before(Date date)如果调用的 Date 对象中包含的日期在 date 指定的日期之前，则返回 true，否则返回 false。 3 | Object clone( )重复调用 Date 对象。 4 | int compareTo(Date date)把调用对象的值与 date 的值进行比较。如果两个值是相等的，则返回 0。如果调用对象在 date 之前，则返回一个负值。如调用对象在 date 之后，则返回一个正值。 5 | int compareTo(Object obj)如果 obj 是 Date 类，则操作等同于 compareTo(Date)。否则，它会抛出一个 ClassCastException。 6 | boolean equals(Object date)如果调用的 Date 对象中包含的时间和日期与 date 指定的相同，则返回 true，否则返回 false。 7 | long getTime( )返回 1970 年 1 月 1 日以来经过的毫秒数。 8 | int hashCode( )为调用对象返回哈希代码。 9 | void setTime(long time)设置 time 指定的时间和日期，这表示从 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位）。 10 | String toString( )转换调用的 Date 对象为一个字符串，并返回结果。  2。格式化时间\n使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和解析日期的具体类。 SimpleDateFormat 允许您选择任何用户定义的日期时间格式化的模式。\n简单的日期格式的格式代码：\n | | -- | ---------------------- | ----------------------- 字符 | 描述 | 实例 G | Era 指示器 | AD y | 四位数表示的年 | 2001 M | 一年中的月 July 或 | 07 d | 一月中的第几天 | 10 h | 带有 A.M./P.M. 的小时（1~12） | 12 H | 一天中的第几小时（0~23） | 22 m | 一小时中的第几分 | 30 s | 一分中的第几秒 | 55 S | 毫秒 | 234 E | 一周中的星期几 | Tuesday D | 一年中的第几天 | 360 F | 所在的周是这个月的第几周 | 2 (second Wed. in July) w | 一年中的第几周 | 40 W | 一月中的第几周 | 1 a | A.M./P.M. 标记 | PM k | 一天中的第几小时（1~24） | 24 K | 带有 A.M./P.M. 的小时（0~11） | 10 z | 时区 Eastern Standard | Time ’ | Escape for text | Delimiter \u0026quot; | 单引号 | `  3.实例\npackage datedeal; import java.io.IOException; import java.io.PrintWriter; import java.text.SimpleDateFormat; import java.util.Date; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Date\u0026quot;) public class DateDeal extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Date date=new Date(); //当前时间 response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); //设置页面编码 response.setHeader(\u0026quot;Refresh\u0026quot;,\u0026quot;1\u0026quot;); //设置页面刷新时间 SimpleDateFormat ft=new SimpleDateFormat (\u0026quot;yyyy.MM.dd '--' hh:mm:ss \u0026quot;); //设置时间格式 //response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); PrintWriter out=response.getWriter(); //取输出流对象一定要在设置编码格式之后 out.println(\u0026quot;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;meta charset=\\\u0026quot;UTF-8\\\u0026quot;\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;title\u0026gt;当前时间\u0026lt;/title\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;body\u0026gt;\u0026quot;+ \u0026quot;\u0026lt;h1 align=\\\u0026quot;center\\\u0026quot;\u0026gt;\u0026lt;b\u0026gt;当前时间：\u0026lt;/b\u0026gt;\u0026lt;/h\u0026gt;\u0026quot;+ft.format(date)+ \u0026quot;\u0026lt;/body\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  ！小细节：在从 HttpServletResponse 对象获得输出流对象一定要在设置返回页面格式，编码之后。否则流对象输出的字符编码很有可能和页面编码不匹配而出现乱码。\n[]()访问结果： "
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%B8%8A%E4%BC%A0/",
	"title": "17. Servlet 实现文件的下载和上传",
	"tags": [],
	"description": "",
	"content": "## []()Servlet 实现文件的下载和上传\n1.文件下载\n实现简单的文件下载主要有以下2步：\n1.读取服务器上的资源文件（包括：获取文件所在目录（绝对路径），文件名）\n2.设置响应格式，编码以及HTTP响应头 （HTTP响应头 “content-disposition” 为：\u0026rdquo;attachment;）\n3.向用户浏览器输出资源文件。\n2.文件下载实例\n下面是一个文件下载的Servlet，用户访问此 Servlet 既可以下载一张图片\n获取资源文件的绝对路径可以用 ：this.getServletContext().getRealPath(\u0026rdquo; 文件名 \u0026ldquo;）\n来获取。\nFileDownload.java 文件如下：\npackage fileDownload; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/FileDownload\u0026quot;) public class FileDownload extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String path=this.getServletContext().getRealPath(\u0026quot;/Download/图片.jpg\u0026quot;); ////获取当前web应用下\u0026quot;Upload\u0026quot;文件夹的绝对路径 String filename=path.substring(path.lastIndexOf(\u0026quot;\\\\\u0026quot;)+1); response.setContentType(\u0026quot;text/html;charset=utf-8\u0026quot;); //设置响应格式及编码 response.setHeader(\u0026quot;content-disposition\u0026quot;,\u0026quot;attachment;filename=\u0026quot;+URLEncoder.encode(filename,\u0026quot;UTF-8\u0026quot;)); //文件名是中文需要用URLEncoder.encode()方法给其重新编为Utf-编码 InputStream in=null; OutputStream out=null; try { in=new FileInputStream(path); int len=0; byte [] buffer=new byte[1024]; out=response.getOutputStream(); while((len=in.read(buffer))\u0026gt;0) { //将文件读入缓冲区 out.write(buffer, 0, len); //向用户机写文件 } }catch(FileNotFoundException e){ e.printStackTrace(); }catch(IOException e){ e.printStackTrace(); }finally{ //关闭资源 if(in!=null) { try { in.close(); }catch(Exception e) { e.printStackTrace(); } } if(out!=null) { try { out.close(); }catch(Exception e) { e.printStackTrace(); } } } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  ！！！由于我是用 Eclipse， 项目的.java文件编译后会放在 Eclipse工作空间的：.metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps 目录下 ，\n！当然获取路径是也是获取在此目录下项目中放置的资源文件，而且我们所创建项目的各种文件都会被映射到此目录下的同名项目里，所以我们在项目的WebContent/木录下创建 Dowmload文件夹和放置 图片.jpg 文件，都会被映射到此目录下。\n（在部署web应用时，导出.war 文件放到Tomcat 目录下会和编写时一样）\n保存文件，启动服务器，在浏览器输入URL：\n然后就可以看见提示保存文件：\n下载就完成了\n3 .文件上传 Servlet3.0\n此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为 Servlet 本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件：\nPart getPart(String name) Collection\u0026lt;Part\u0026gt; getParts()  前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：\nPart photo = request.getPart(\u0026quot;photo\u0026quot;); photo.write(\u0026quot;/tmp/photo.jpg\u0026quot;); // 可以将两行代码简化为 request.getPart(\u0026quot;photo\u0026quot;).write(\u0026quot;/tmp/photo.jpg\u0026quot;) 一行。  另外，开发者可以配合 @MultipartConfig 注解来对上传操作进行一些自定义的配置，比如限制上传文件的大小，以及保存文件的路径等。其用法非常简单，故不在此赘述了。\n需要注意的是，如果请求的 MIME 类型不是 multipart/form-data，则不能使用上面的两个方法，否则将抛异常。\n上传文件的 form 表单的 method 属性必须文 post 方法，enctype 必须为 multipart/form-data 。然后 input 标签的 type 属性必须为 file。\n4.文件上传实例\nFileUp.html文件如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;上传文件\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot; action=\u0026quot;FileUpload\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;myfile1\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;myfile2\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;myfile3\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;上传文件\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  action=“FileUpload”\nFileUpload.java 文件如下：\npackage fileupload; import java.io.IOException; import java.io.PrintWriter; import java.text.SimpleDateFormat; import java.util.Collection; import java.util.Date; import javax.servlet.ServletException; import javax.servlet.annotation.MultipartConfig; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.Part; @WebServlet(\u0026quot;/FileUpload\u0026quot;) //设置上传文件保存路径的第一种方式 @MultipartConfig()//(location=\u0026quot;绝对路径\u0026quot;)// 设置文件上传路径（绝对路径可以设置） public class FileUpload extends HttpServlet { private static final long serialVersionUID = 1L; private int i = 1;// 用于给文件命名的数字 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\u0026quot;text/html;charset=utf-8\u0026quot;); //设置响应格式 String savePath=this.getServletContext().getRealPath(\u0026quot;/Upload/\u0026quot;); //获取当前web应用下\u0026quot;Upload\u0026quot;文件夹的绝对路径 Collection\u0026lt;Part\u0026gt; parts = request.getParts(); // 获取上传文件集合 Date date = new Date(); for (Part part : parts) { if(part.getSize()!=0) { String fileName=MygetName(part.getHeader(\u0026quot;content-disposition\u0026quot;),date); //part.write(fileName); // 设置上传文件保存路径的第二种方法 part.write(savePath+fileName); i++; } } PrintWriter out = response.getWriter(); out.println(\u0026quot;上传成功 !\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } public String MygetName(String disposition, Date date) { SimpleDateFormat sf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); //利用时间以及 i 生成唯一的文件名 String filename = sf.format(date) + \u0026quot;_\u0026quot; + this.i + \u0026quot;_\u0026quot; + disposition.substring(disposition.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1,disposition.length()-1); //生成文件名 return filename; } }  在上面的实例中，主要用part 对象获取文件写入到服务器，用this.getServletContext().getRealPath(\u0026ldquo;/Upload/\u0026rdquo;) 获取文件写入的路径，也就是保存目录，但是保存的是在上述 .metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps 目录映射的web应用的文件夹下，所以在Eclipse 项目的web应用中没有（就是这个整了半天 : ( )\n（1）选择要上传的文件如下：\n（2）上传成功：\n（3）然后在Eclipse 项目里一直都没有： ：(\n（4）然后去上面说的目录下一看：\n果然有，而且上传了几遍。。。。\n最后文件上传还有几点需要注意：\n（1）@MultipartConfig() 注解可以使用，但是要给绝对路径。用相对路径获取会获取到一些奇怪的目录下。\n（2）尽量用相对路径获取 文件保存的path ，在以后部署，迁移项目时有更好的移植性。（this.this.getServletContext().getRealPath（）方法）\n（3）尽量用 随机数或者我上述的方法来生成不同的文件名，以防服务器保存文件发生错误。\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/servlet-%E7%BD%91%E9%A1%B5%E9%87%8D%E5%AE%9A%E5%90%91%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E7%BD%91%E7%AB%99%E7%82%B9%E5%87%BB%E9%87%8F%E7%BB%9F%E8%AE%A1/",
	"title": "18. Servlet 网页重定向,控制页面刷新，网站点击量统计",
	"tags": [],
	"description": "",
	"content": "版权声明： https://blog.csdn.net/ak_csdno/article/details/88141771\n## []()Servlet 网页重定向,控制页面刷新，网站点击量统计\n1. 网页重定向\n在Servlet中重定向网页主要有以下两种方式：\n（1） 使用response.sendRedirect(String URL) (URL的根目录是web容器，即需要在Servlet的对外访问路径前加上项目名限定，如：/web应用名/Servlet对外访问路径)\n（2）使用 response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)\nresponse.setHeader(“location”,“目标URL”) 设置Status和HTTP头重定向网页\n（值得说明的是 SC_MOVED_TEMPORARILY是HttpServletResponse类的静态变量）\n实例\npackage servletMIX; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Redirect\u0026quot;) public class Redirect extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // response.sendRedirect(\u0026quot;/Servlet/Date\u0026quot;); //使用response.sendRedirect()方法重定向 response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY); // 设置Status和HTTP头重定向 response.setHeader(\u0026quot;location\u0026quot;, \u0026quot;/Servlet/Date\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  运行结果：\n在浏览器地址栏输入：http://localhost:8080/Servlet/Redirect 如下：回车后发现已经跳转到了重定向的目标网页：http://localhost:8080/Servlet/Date\n2.控制页面刷刷新\n控制浏览器页面刷新的主要原理是：设置HTTP响应头：Refersh ，值为数字字符串，单位为秒。在Servlet中一般都是通过 HttpServletResponse 类实列的 setHeader() 来设置HTTP响应头.\n实例\npackage servletMIX; import java.io.IOException; import java.io.PrintWriter; import java.text.SimpleDateFormat; import java.util.Date; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Refersh\u0026quot;) public class Refersh extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Date date = new Date(); // 当前时间 response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); // 设置页面编码 response.setHeader(\u0026quot;Refresh\u0026quot;, \u0026quot;1\u0026quot;); // 设置页面刷新时间 SimpleDateFormat ft = new SimpleDateFormat(\u0026quot;yyyy.MM.dd '--' hh:mm:ss \u0026quot;); // 设置时间格式 // response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); PrintWriter out = response.getWriter(); out.println(\u0026quot;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;html\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;meta charset=\\\u0026quot;UTF-8\\\u0026quot;\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;title\u0026gt;当前时间\u0026lt;/title\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/head\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;body\u0026gt;\u0026quot; + \u0026quot;\u0026lt;h1 align=\\\u0026quot;center\\\u0026quot;\u0026gt;\u0026lt;b\u0026gt;当前时间：\u0026lt;/b\u0026gt;\u0026lt;/h\u0026gt;\u0026quot; + ft.format(date) + \u0026quot;\u0026lt;/body\u0026gt;\\r\\n\u0026quot; + \u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  运行结果：\n当前页面的时间就会一直刷新为当前时间。\n3.统计网页点击量\n用Servlet 来写的话不容易统计整个网页全局的点击量：一边情况下用 过滤器来实现就方便的多。主要原理就是在过滤器类里声明一个数字类型的变量，然后过滤器 过滤所有目录用 @WebFilter(\u0026ldquo;\u0026rdquo;) 来设置过滤的范围 /* 代表整个web应用，设置后可过滤当前web应用的所有访问，然后过滤器类的 doFilter() 方法在每一次过滤都会执行，就可以用来增加变量的值，来统计网页点击量。\n实例\npackage servletMIX; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; @WebFilter(\u0026quot;/*\u0026quot;) public class Counter implements Filter { private int count; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { setCount(getCount() + 1);\tresponse.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); PrintWriter out=response.getWriter();\tout.println(\u0026quot;\u0026lt;b\u0026gt;网站点击量 : \u0026quot;+getCount()+\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); //System.out.println(\u0026quot;\u0026lt;b\u0026gt;网站访问人数 : \u0026quot;+getCount()+\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;);\tchain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { //System.out.println(\u0026quot;过滤器启动！\u0026quot;); count = 0; } public void destroy() { } public int getCount() { return count; } public void setCount(int count) { this.count = count; } }  运行结果，会在Servlet处理返回的响应页面上出现：加粗的 网站点击量 ：XX\n如下图所示：\n"
},
{
	"uri": "https://compass-ak.gitee.io/java/web/web%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5/",
	"title": "19. 数据库的连接",
	"tags": [],
	"description": "",
	"content": " #一. 连接 mysql 数据库\n#####1.驱动下载\n下载连接：https://dev.mysql.com/downloads/\n进入页面点击Community，选择下方的MySQL Connectors，选择Connector/J，如下图所示。\n进入页面Select Operating System: 选择Platform Independent ，选择完后页面如下，点击Download即可下载，压缩文件。如下图所示。\n#####2.连接数据库准备\n驱动下载完成解压后，复制根目录下的 ：mysql-connector-java-8.0.15.jar 文件到Web项目的 WEB-INF/lib 目录下。然后鼠标右键项目，选择Build Path 在Libraries 里点击Classpath选择添加 Add JAR 选择项目目录下的 mysql-connector-java-8.0.15.jar 文件添加。\n[]()3.连接数据库 （1.利用反射类加载数据库驱动类：\nmysql 8.x驱动类位置为： com.mysql.cj.jdbc.Driver 中间多了一个 .cj\n**反射加载驱动类： Class.forName(\u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;); **\n**URL： \u0026quot;jdbc:mysql://localhost:3306/数据库名\u0026quot;,User,password **\n（2.实例代码（servlet实现）：\npackage mysql; import java.io.IOException; import java.io.PrintWriter; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.sql.Statement; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(\u0026quot;/Mysql\u0026quot;) public class Mysql extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Connection conn = null; Statement stat = null; ResultSet resu = null; try { Class.forName(\u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;); conn = DriverManager.getConnection(\u0026quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC\u0026quot;, \u0026quot;root\u0026quot;, “\u0026quot;*************\u0026quot;); //获取数据库连接 stat = conn.createStatement(); resu = stat.executeQuery(\u0026quot;select * from city where CountryCode='CHN'\u0026quot;); //执行查询返回结果 response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); PrintWriter out = response.getWriter(); out.println(\u0026quot;china city info: \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;\u0026quot;); ResultSetMetaData meta = resu.getMetaData(); //获取元数据 int ColumnCount = meta.getColumnCount(); for (int i = 1; i \u0026lt; ColumnCount; i++) { String name = meta.getColumnName(i); //获取列名 out.println(name + \u0026quot; \u0026quot;); } while (resu.next()) { for (int i = 1; i \u0026lt; ColumnCount; i++) { String data = resu.getString(meta.getColumnName(i)); //根据列名获取数据 out.println(data + \u0026quot; \u0026quot;); } out.println(\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;); } out.flush(); out.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); System.out.println(\u0026quot;数据库驱动加载失败！\u0026quot;); } catch (SQLException e) { e.printStackTrace(); System.out.println(\u0026quot;获取数据库连接失败！\u0026quot;); } finally { try { resu.close(); stat.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); System.out.println(\u0026quot;数据库关闭失败\u0026quot;); } } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }  []()4.访问页面 []()二.连接 SqlServer 数据库 []()1.驱动下载 下载连接：https://www.microsoft.com/zh-cn/download/details.aspx?id=11774\n进入页面点击下载，选择驱动下载即可。\n[]()2.连接数据库准备 与 mysql 操作类似。\n[]()3.连接数据库 （1.利用反射类加载数据库驱动类：\nSqlServer jdbc驱动6.0 驱动类位置为： \u0026quot;com.microsoft.sqlserver.jdbc.SQLServerDriver\u0026quot;\n**反射加载驱动类： Class.forName(\u0026quot;com.microsoft.sqlserver.jdbc.SQLServerDriver\u0026quot;); **\n**url： jdbc:sqlserver://localhost:1433;DatabaseName=数据库名;user=***;password=**** **\n（2.实例代码（jsp实现）：\n\u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot;%\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.Connection\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.Statement\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.ResultSet\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.DriverManager\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.ResultSetMetaData\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.sql.SQLException\u0026quot; %\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Insert title here\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;% Connection conn = null; Statement stat = null; ResultSet resu = null; try { Class.forName(\u0026quot;com.microsoft.sqlserver.jdbc.SQLServerDriver\u0026quot;); conn = DriverManager.getConnection( \u0026quot;jdbc:sqlserver://localhost:1433;DatabaseName=BooksMS;user=Admin;password=2438675\u0026quot;); stat = conn.createStatement(); resu = stat.executeQuery(\u0026quot;select * from Books\u0026quot;); response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); out.println(\u0026quot;ALL Books info: \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;\u0026quot;); %\u0026gt;\u0026lt;table border=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;% ResultSetMetaData meta = resu.getMetaData(); int ColumnCount = meta.getColumnCount(); %\u0026gt;\u0026lt;tr align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;% for (int i = 1; i \u0026lt; ColumnCount; i++) { %\u0026gt;\u0026lt;td\u0026gt;\u0026lt;% String name = meta.getColumnName(i); out.println(name + \u0026quot; \u0026quot;); %\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;% } %\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;% while (resu.next()) { %\u0026gt;\u0026lt;tr align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;% for (int i = 1; i \u0026lt; ColumnCount; i++) { %\u0026gt;\u0026lt;td\u0026gt;\u0026lt;% String data = resu.getString(meta.getColumnName(i)); out.println(data + \u0026quot; \u0026quot;); %\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;% } %\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;% } %\u0026gt;\u0026lt;/table\u0026gt;\u0026lt;% //out.flush(); //out.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); System.out.println(\u0026quot;数据库驱动加载失败！\u0026quot;); } catch (SQLException e) { e.printStackTrace(); System.out.println(\u0026quot;获取数据库连接失败！\u0026quot;); } finally { try { resu.close(); stat.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); System.out.println(\u0026quot;数据库关闭失败\u0026quot;); } } %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  []()4.访问页面 完…\n"
},
{
	"uri": "https://compass-ak.gitee.io/python/selenium/selenium/",
	"title": "1. Selenium",
	"tags": [],
	"description": "",
	"content": " 1. selenium 介绍 Selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera，Edge等。\n框架底层使用JavaScript模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。\n2. selenium 用途，特性  一般用于Web应用程序测试，但是由于它能模拟人操作浏览器，所以它可以干的事就非常多了。 理论上只要是需要人对浏览器做的繁琐的，重复性高的操作都可以使用它来帮我们完成。\n 支持多种编程语言：C、java、python、C#\n 免费开源支持多平台：windows、linux、MAC\n  3. selenium 的使用（Python）  安装selenium\npip install selenium  下载浏览器驱动\n   Google Chrome 驱动：https://chromedriver.storage.googleapis.com/index.html\n Mozilla Firefox 驱动：https://github.com/mozilla/geckodriver/releases\n Microsoft Edge 驱动：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n 下载\n  Demo 1 流程：打开百度，输入搜索关键字 selenium 点击搜索\nfrom selenium import webdriver from time import sleep #1.创建浏览器驱动对象 driver = webdriver.Edge(executable_path=\u0026quot;C:\\\\Users\\\\ASUS\\\\Desktop\\\\demo\\\\driver\\\\msedgedriver\u0026quot;) #driver = webdriver.Firefox(executable_path=\u0026quot;C:\\\\Users\\\\ASUS\\\\Desktop\\\\demo\\\\driver\\\\geckodriver\u0026quot;) #driver = webdriver.Chrome(executable_path=\u0026quot;C:\\\\Users\\\\ASUS\\\\Desktop\\\\demo\\\\driver\\\\chromedriver\u0026quot;) #2.设置访问地址 driver.get(\u0026quot;https://www.baidu.com/\u0026quot;) driver.maximize_window() sleep(2) #3.设置搜索内容 element=driver.find_element_by_id(\u0026quot;kw\u0026quot;) element.send_keys(\u0026quot;selenium\u0026quot;) #4.点击搜索 driver.find_element_by_id(\u0026quot;su\u0026quot;).click() sleep(3) #5.关闭浏览器 driver.close()  Demo 2 获取豆瓣电影Top250简介页面截图\nimport time from PIL import Image from selenium import webdriver from selenium.webdriver.common.by import By class TestTest(): # 初始化 def setup_method(self, method): self.driver = webdriver.Firefox() self.vars = {} def teardown_method(self, method): self.driver.quit() # 截图保存 def elementShot(self, element, i): self.driver.save_screenshot(\u0026quot;./images/\u0026quot;+str(i)+\u0026quot;.png\u0026quot;) left = element.location['x'] top = element.location['y'] right = element.location['x'] + element.size['width'] #bottom = element.location['y'] + element.size['height'] bottom = 644 im = Image.open(\u0026quot;./images/\u0026quot;+str(i)+\u0026quot;.png\u0026quot;) im = im.crop((left, top, right, bottom)) im.save(\u0026quot;./images/\u0026quot;+str(i)+\u0026quot;.png\u0026quot;) # 行为方法 def test_test(self): self.driver.get(\u0026quot;https://movie.douban.com/\u0026quot;) #self.driver.maximize_window() self.driver.find_element(By.LINK_TEXT, \u0026quot;排行榜\u0026quot;).click() self.driver.find_element(By.LINK_TEXT, \u0026quot;全部\u0026quot;).click() # 置计数器为1 counter = 1 for i in range(1,251): if counter == 26: self.driver.find_element(By.LINK_TEXT, \u0026quot;后页\u0026gt;\u0026quot;).click() counter = 1 time.sleep(2) time.sleep(2) self.driver.find_element_by_xpath(\u0026quot;/html/body/div[3]/div[1]/div/div[1]/ol/li[\u0026quot;+ str(counter)+\u0026quot;]/div/div[2]/div[1]/a/span[1]\u0026quot;).clic() time.sleep(2) element = self.driver.find_element_by_id(\u0026quot;wrapper\u0026quot;) # 截图保存 print(str(i)+\u0026quot; done\u0026quot;) self.elementShot(element, i) self.driver.back() counter += 1 if __name__ == '__main__': t = TestTest() t.setup_method(t) t.test_test()  Selenium IDE Selenium IDE 是开源Web自动化测试工具。它不需要任何编程逻辑来编写其测试脚本，而只需记录与浏览器的交互以创建测试用例。之后，可以使用播放选项重新运行测试用例。\n"
},
{
	"uri": "https://compass-ak.gitee.io/",
	"title": "AKblog",
	"tags": [],
	"description": "",
	"content": " AKblog 了解世界 "
},
{
	"uri": "https://compass-ak.gitee.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://compass-ak.gitee.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]