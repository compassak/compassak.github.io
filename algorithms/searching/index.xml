<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Searching on en</title>
    <link>https://compass-ak.gitee.io/algorithms/searching/</link>
    <description>Recent content in Searching on en</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 May 2020 22:41:33 +0800</lastBuildDate>
    
	<atom:link href="https://compass-ak.gitee.io/algorithms/searching/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. Binary-Search</title>
      <link>https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 14 Jun 2020 08:27:04 +0800</pubDate>
      
      <guid>https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</guid>
      <description>二分查找 二分查找也称为折半查找（Binary Search），是一种效率较高的查找方法。它的一般查找过程为：首先，需要将待查的线性表按关键字排序，然后将表中间位置的元素的关键字与查找关键字比较。如果二者相等，则查找成功。如果不相等，则使用表的中间位置元素将表分为左右两个子表，查找关键字大于中间位置元素的关键字 -&amp;gt; 继续查询右子表；查找关键字小于中间元素的关键子 -&amp;gt; 继续查询左子表。重复以上过程直到查找到满足查询条件的元素，若最后细分到无法再划分子表时则没有此元素查询失败。由二分查找的原理我们很容易得出其时间复杂度为：lgN（以2为底）。
1. 基于有序数组的二分查找 想要在一个数组查找到一个元素的索引，最普通的方法就是将数组遍历一遍，将元素的关键字逐个的与查找关键字比较，直到找到元素返回其索引。这种方法的时间复杂度是线性级别的，在数组长度非常大且处于最坏的情况时，可能是无法解决的。而二分法就将解决这个这个问题的时间复杂度降低到了对数级别。如果数组长度为：100000000000, 在最坏的情况下，前者需要循环访问数组：1000亿次，而后者只需要访问数组约：36.5412次。这简直是降维打击，让我们能在有限算力的计算机上解决更多问题。下面是一个基于有序数组二分查找的实现。
Java
public class BinarySearch { //二分法查找元素的索引 public static int Search(int[] a, int key){ int lo=0, hi = a.length-1; while (lo &amp;lt;= hi){ int mid = lo + (hi-lo)/2; if (key &amp;gt; a[mid]) lo = mid + 1; else if (key &amp;lt; a[mid]) hi = mid - 1; //found else return mid; } //not found return -1; } }  可以看到基于有序数组的二分查找实现非常简单，只需要两个辅助指针即可完成。</description>
    </item>
    
    <item>
      <title>2. Binary-Search-Tree</title>
      <link>https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</link>
      <pubDate>Fri, 12 Jun 2020 08:27:04 +0800</pubDate>
      
      <guid>https://compass-ak.gitee.io/algorithms/searching/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</guid>
      <description>二叉查找树 我们都知道在一定程度上，程序 = 算法 + 数据结构。抛开数据结构说算法；抛开算法说数据结构，都是不太妥当的。而衡量一种数据结构的优略，一是看具体的问题需求，二是看其插入，删除排序等各个方面的性能。
在二分查找中我们使用的经典的数组实现，在查询的效率上直接达到了 lgN 对数级别的效率。但是数组这种数据结构在插入元素时，就有些力不从心了。在最坏的情况下使用基于二分查找的数组插入一个元素需要N的时间成本。
而二叉查找树就是一种能将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构，在平均情况下可以实现对数级别的插入和查询操作。
1. 二叉查找树 定义：一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个键以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。
2. 实现 由于二叉查找树不是一个完全二叉树，所以难以用数组很难去表示它。这就需要写一个类来表示二叉查找树上的一个结点。每一个节点需要含有一个键，一个值，一条指向左子结点的链接，一条指向右子结点的链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。结点计数器 给出了以该结点为根的子树的结点总数。
1.查找元素
根据二叉查找树的定义和性质，我们可以得出以下查找某一元素的算法：
如果树是空的，则查找未命中； 如果被查找的键和根结点的键相等，查找命中； 如果未命中我们就在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。 如果最后没有找到该元素，则返回null；
2.插入元素
插入元素算法的实现逻辑和查找很相似：
如果树是空的，就返回一个含有该键值对的新结点； 如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，在相等时更新结点的value值，否则在右子树中插入该键，并返回结点引用。 更新结点计数器
3.rank排名
rank 从1开始排序, 查找元素按键值排序的排名，根据二叉查找树的性质，算法思路如下：
如果给定的键和根结点的键相等，我们返回左子树中的结点总数 t； 如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）； 如果给定的键大于根结点，我们会返回 t+1（根结点）加上它在右子树中的排名（递归计算）。
二叉查找树的完整实现如下，上述 1.查找元素， 2.插入元素， 3.rank排名 分别对应方法：get(), put(), rank()。
Java
public class BinarySearchTree { private Node root; //根节点 /** * 节点静态内部类 */ private static class Node { private int key; //节点键 private String value; //节点值 private Node left, right; //指向左右子树的连接 private int N; //以该节点为根的子树的节点数 Node(int key, String value, int N) { this.</description>
    </item>
    
    <item>
      <title>3. Red-Black-BST</title>
      <link>https://compass-ak.gitee.io/algorithms/searching/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Sun, 14 Jun 2020 08:27:04 +0800</pubDate>
      
      <guid>https://compass-ak.gitee.io/algorithms/searching/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>红黑二叉查找树 -图片资料来自 Algorithms, 4th Edition
基于二叉查找树的查找和插入算法已经可以应用在许多的用例特定的应用程序上，但是在最坏的情况下，其结构退化为链表的性能急剧降低。这是让人无法容忍的。
由于二叉查找树的查询性能依赖于树的形态，如果可以找到一种方法可以让二叉查找树无论如何构造，都可以处于一个平衡的状态。我们就可以在更多的情况下应用二叉查找树的高效查找和插入等操作。
在理想情况下我们希望二叉查找树能在每次插入，删除等操作后都保持一个完美的平衡状态。在一颗含有N个结点的二叉查找树中，树高为lgN。这样就可以保证在lgN次比较内查询到元素，达到二分查找的性能。
但是实际情况是，在动态的插入和删除等操作中保持二叉查找树的完美平衡的代价太高了，我们需要降低要求，让二叉查找树保持一个接近于完美平衡的状态。这就是红黑二叉查找树。
1. 2-3查找树 学习红黑二叉查找树之前，我们需要先了解2-3查找树，它可以让我们更好的了解红黑二叉查找树保持树平衡的原理。
在一般情况下，我们将一颗标准二叉查找树上的结点称为：2-结点（含有一个键和两条链接）。为了保持树的平衡性，在一颗2-3查找树中还含有：3-结点（含有两个键三条链接）,左链接指向的 2-3 树中的键都小于该结点，中链接指向的 2-3 树中的键都位于该结点的两个键之间，右链接指向的 2-3树中的键都大于该结点。下图所示就是一颗2-3查找树。
2-3 树
了解2-3查找树的基本结构后，我们进一步学习分析2-3查找树如何完成二叉查找树的各项功能，以及其保持树的完美平衡的方法。
1.1 查找
2-3查找树的查找算法与二叉查找树基本类似，只是2-3树会多一些判断，只要将二叉查找树的查找算法一般化我们就可以得到2-3查找树的算法。判断一个键是否在2-3查找树中的基本流程为：
 将查找键与根结点中的键比较，如果它与其中任意一个是等，查找命中。
 若未命中，根据比较结果确定查找键对应的区间，根据区间的链接找到子树继续递归的查找。
 如果链接最后为空链接，则查询未命中。
  1.2 向2-结点插入新键
在二叉查找树中，进行一个插入操作首先会进行一次未命中查找。然后将新结点插入到树的底部，这样就有可能破坏树的平衡性。
而在一颗2-3查找树中，如果查找未命中结束于一个2-结点。我们只需要将2-结点替换为3-结点。将需要插入的键保存在其中即可，如下图所示。
向2-结点插入新键
1.3 向3-结点插入新键
向3-结点中插入新键就比向2-结点中插入新键要更复杂一些，因为3-结点已经含有了两个键没有插入空间了。但是为了将新键插入，我们可以键该键临时的存入该结点中,该结点就成为了一个4-结点（含有3个键4条链接）。由于4-结点是临时的，我们必须将它分解变换成2-结点或3-结点，一颗4-结点很容易转换成一颗由3个2-结点构成的2-3查找树。原4-结点中的中间结点成为此树的根节点。这颗树既是一个3个结点的二叉树，也是一颗完美平衡的2-3树。转换的过程揭示了一颗2-3树是如何 “生长” 的。具体如下图所示。
向3-结点插入新键
1.4 向一个父结点是2-结点的3-结点中插入新键
假设一次插入的未命中查找操作结束于一个3-结点，且它的父结点是一颗2-结点。在这种情况下我们需要保持树的完美平衡的前提下，将新键插入。我们可以像在1.3节中描述的一样，将3-结点临时的转换为一个4-结点，但是此时我们不能直接将4-结点分解为2-结点，因为此操作会破坏2-3树的完美平衡。我们将4-结点的中键上移存入原来父结点中。其他两个键分解为2个2-结点，连接在父结点原中键两端的链接上。由于原来的父结点是2-结点有插入空间，可以直接将中键插入到此结点中。经过此操作2-3树任是完美平衡的，所有的空链接到根结点的距离仍然相等，具体过程如下图所示。
向一个父结点是2-结点的3-结点中插入新键
1.5 向一个父结点是3-结点的3-结点中插入新键
假设一次插入的未命中查询操作结束于一个父结点为3-结点的3结点中。和1.4一样我们先构造一个临时的4-结点，然后将它的中键移动到父结点中。但是父结点也是一个3-结点，因此我们需要再次构建一个临时4-结点，然后进行相同的变换，分解结点并将中键移动到父结点中。如果路径上的结点除开根结点全部都是3-结点，我们就需要一直重复构建和分解临时的4-结点，将中键插入更高层的父结点中。直到最后达到根结点。具体过程如下图所示。
向一个父结点是3-结点的3-结点中插入新键
1.6 分解根结点
如果从插入结点到到根节点全部都是3-结点，在经历数次变换后根结点最后会变换成一个临时的4-结点。此时我们就可以直接将4-结点直接分解为3个2-结点，它的中键变成新的根节点，左右两个键连接在新的根结点的左右链接上。操作完成后树高加1，如下图所示。显而易见此次变换的仍保持了2-3树的完美平衡性。
分解根结点
1.7 全局性质
将一个 4- 结点分解为一棵 2-3 树可能有 6 种情况，都总结在了图 3.3.8 中。这个 4- 结点可能是根结点，可能是一个 2- 结点的左子结点或者右子结点，也可能是一个 3- 结点的左子结点、中子结点或者右子结点。 2-3 树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。每个变换都会将 4- 结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</description>
    </item>
    
    <item>
      <title>4. Hash-Tables</title>
      <link>https://compass-ak.gitee.io/algorithms/searching/%E6%95%A3%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 06 Jul 2020 18:12:57 +0800</pubDate>
      
      <guid>https://compass-ak.gitee.io/algorithms/searching/%E6%95%A3%E5%88%97%E8%A1%A8/</guid>
      <description>散列表 使用基于红黑二叉查找树实现的查找算法，在平均情况下可以达到logN的效率。算法时间复杂度中，最小最优的就是常数级别的复杂度。有没有一种算法可以突破logN的查询复杂度到达常数级别的效率？答案就是散列表（Hash-Tables）
使用散列表需要将键转化为数组的索引，进而使用这个索引实现对数组中键值对的快速访问。这就产生了两个需要解决的问题：
 怎么由键转化为数组索引；
 如何处理转化后索引的冲突。
  将键转化为数组的索引需要一个 散列函数 ， 散列函数 的理想目的是将可能用例的不同的键都可以转化为不同的索引值。但是这样的散列函数目前是不存在的，所以转化时一定会出现索引冲突的情况，也就是多个键转化后对应一个索引值。在散列查找中解决索引冲突一般使用两种方法： 拉链法 和 线性探测法 。
1. 散列函数 散列函数用于解决上述第一个问题，将键转化为数组索引。如果我们有一个长度为M的数组用于存储键值对，那么我们就需要一个可以将任意键值转化为该数组的索引范围（ [0, M-1] ）内整数的 散列函数 。散列函数应该是能使所有键分布均匀且易于计算。
散列函数的设计与键的类型有很大的关系。确切的说，对于每一种类型的键我们都需要寻找一个与之对应的散列函数。
1.1 正整数
将整数散列最常用的方法是： 除留余数法 。选择一个大小的为素数 M 的数组，对于任意的整数键 k，计算 k 除 M 的余数作为在数组中的索引。此散列函数能很有效的将键散布在 [0，M-1] 的范围内。选取素数是因为其特殊的数学性质能更好的将键散列，选取其他数（最坏的情况是：如果键是10进制数而数组的大小为10^k，那么散列函数就只能利用到键的后K位数）可能会产生很多的索引冲突。
1.2 浮点数
如果键是一个 0 到 1 之间的浮点数，我们可以将其乘以 M 后四舍五入得到一个整数作为其的索引值。此方法便于理解和计算，但是浮点数小数的低位对散列结果的影响没有高位的大。在一些特殊情况：浮点数小数的高位都一样而低位不同，散列的情况就可能非常的糟糕。解决这个问题的方法是将键转化为二进制表示，然后再使用除留取余法。
1.3 字符串
对于字符串这种一般较长的键，也可以使用除留取余法。只需要将字符串当作一个较大的整数就行。具体例子如下：
int hash = 0; for (int i = 0; i &amp;lt; s.length(); i++) hash = (R * hash + s.</description>
    </item>
    
  </channel>
</rss>